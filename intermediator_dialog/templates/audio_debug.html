<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Audio Debug Monitor - IDi</title>
    <script src="https://cdn.socket.io/4.5.4/socket.io.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            background: #1a1a1a;
            color: #e0e0e0;
            padding: 20px;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
        }

        h1 {
            color: #6ba3d8;
            margin-bottom: 20px;
            font-size: 24px;
        }

        .panel {
            background: #2d2d2d;
            border: 1px solid #404040;
            border-radius: 8px;
            padding: 16px;
            margin-bottom: 20px;
        }

        .panel h2 {
            color: #6ba3d8;
            font-size: 18px;
            margin-bottom: 12px;
            border-bottom: 1px solid #404040;
            padding-bottom: 8px;
        }

        .status-item {
            padding: 8px 12px;
            background: #252525;
            border-left: 4px solid #4472c4;
            margin-bottom: 8px;
            border-radius: 4px;
            font-size: 13px;
        }

        .status-item.success {
            border-left-color: #70ad47;
        }

        .status-item.error {
            border-left-color: #c55a11;
        }

        .status-item.warning {
            border-left-color: #ffc000;
        }

        .timestamp {
            color: #808080;
            font-size: 11px;
            margin-right: 8px;
        }

        .queue-item {
            display: flex;
            align-items: center;
            padding: 10px 12px;
            background: #252525;
            border: 1px solid #404040;
            border-radius: 4px;
            margin-bottom: 6px;
        }

        .queue-item.playing {
            border-left: 4px solid #70ad47;
            background: #2d3528;
        }

        .queue-number {
            background: #4472c4;
            color: white;
            padding: 4px 10px;
            border-radius: 4px;
            font-weight: 600;
            margin-right: 12px;
            min-width: 40px;
            text-align: center;
        }

        .queue-item.playing .queue-number {
            background: #70ad47;
        }

        .queue-filename {
            flex: 1;
            font-family: 'Courier New', monospace;
            font-size: 13px;
        }

        .empty-state {
            text-align: center;
            padding: 40px;
            color: #808080;
            font-style: italic;
        }

        .stats {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 12px;
            margin-bottom: 16px;
        }

        .stat-box {
            background: #252525;
            padding: 12px;
            border-radius: 4px;
            text-align: center;
        }

        .stat-value {
            font-size: 28px;
            font-weight: 600;
            color: #6ba3d8;
        }

        .stat-label {
            font-size: 11px;
            color: #808080;
            margin-top: 4px;
        }

        .log-entry {
            font-family: 'Courier New', monospace;
            font-size: 12px;
            padding: 6px 10px;
            background: #252525;
            border-left: 3px solid #404040;
            margin-bottom: 4px;
            border-radius: 2px;
        }

        .log-entry.tts-start {
            border-left-color: #4472c4;
        }

        .log-entry.tts-success {
            border-left-color: #70ad47;
        }

        .log-entry.tts-error {
            border-left-color: #c55a11;
        }

        .log-entry.audio-queued {
            border-left-color: #ffc000;
        }

        .log-entry.debug-log {
            border-left-color: #808080;
            color: #b0b0b0;
        }

        .controls {
            margin-bottom: 16px;
        }

        button {
            background: #4472c4;
            color: white;
            border: none;
            padding: 8px 16px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 13px;
            margin-right: 8px;
        }

        button:hover {
            background: #365899;
        }

        button.danger {
            background: #c55a11;
        }

        button.danger:hover {
            background: #833c0c;
        }

        .scroll-container {
            max-height: 400px;
            overflow-y: auto;
        }

        .scroll-container::-webkit-scrollbar {
            width: 8px;
        }

        .scroll-container::-webkit-scrollbar-track {
            background: #252525;
        }

        .scroll-container::-webkit-scrollbar-thumb {
            background: #404040;
            border-radius: 4px;
        }

        .scroll-container::-webkit-scrollbar-thumb:hover {
            background: #555555;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>üîä Audio Player & Monitor</h1>

        <div class="panel">
            <h2>Statistics</h2>
            <div class="stats">
                <div class="stat-box">
                    <div class="stat-value" id="statGenerated">0</div>
                    <div class="stat-label">TTS Generated</div>
                </div>
                <div class="stat-box">
                    <div class="stat-value" id="statQueued">0</div>
                    <div class="stat-label">In Queue</div>
                </div>
                <div class="stat-box">
                    <div class="stat-value" id="statPlayed">0</div>
                    <div class="stat-label">Played</div>
                </div>
                <div class="stat-box">
                    <div class="stat-value" id="statErrors">0</div>
                    <div class="stat-label">Errors</div>
                </div>
            </div>
        </div>

        <div class="panel">
            <h2>Playback Queue</h2>
            <div class="controls">
                <label style="display: inline-flex; align-items: center; margin-right: 16px; cursor: pointer;">
                    <input type="checkbox" id="autoPlayToggle" checked onchange="toggleAutoPlay()" style="margin-right: 6px;">
                    <span>Auto-play (enabled by default)</span>
                </label>
                <button onclick="playNextAudio()">‚ñ∂ Play Next</button>
                <button onclick="clearQueue()">Clear Queue</button>
                <button class="danger" onclick="clearLogs()">Clear Logs</button>
            </div>
            <div id="queueContainer">
                <div class="empty-state">Queue is empty</div>
            </div>
        </div>

        <div class="panel">
            <h2>Dialog Turn Tracker</h2>
            <div class="scroll-container" id="turnTracker">
                <div class="empty-state">No dialog turns yet</div>
            </div>
        </div>

        <div class="panel">
            <h2>TTS Generation Log</h2>
            <div class="scroll-container" id="ttsLog">
                <div class="empty-state">No TTS activity yet</div>
            </div>
        </div>

        <div class="panel">
            <h2>Audio Playback Log</h2>
            <div class="scroll-container" id="audioLog">
                <div class="empty-state">No audio playback yet</div>
            </div>
        </div>
    </div>

    <script>
        const socket = io();

        // Statistics
        let stats = {
            generated: 0,
            queued: 0,
            played: 0,
            errors: 0
        };

        // Queue tracking and playback
        let audioQueue = [];
        let currentlyPlaying = null;
        let audioPlayer = null;
        let isPlaying = false;
        let autoPlayEnabled = true; // Auto-play by default

        // Log entries
        let ttsLogs = [];
        let audioLogs = [];

        // Turn tracking
        let dialogTurns = [];
        let turnTTSStatus = {}; // Maps turn key to TTS status

        function updateStats() {
            document.getElementById('statGenerated').textContent = stats.generated;
            document.getElementById('statQueued').textContent = audioQueue.length;
            document.getElementById('statPlayed').textContent = stats.played;
            document.getElementById('statErrors').textContent = stats.errors;
            stats.queued = audioQueue.length;
        }

        function updateQueue() {
            const container = document.getElementById('queueContainer');

            if (audioQueue.length === 0 && !currentlyPlaying) {
                container.innerHTML = '<div class="empty-state">Queue is empty</div>';
                return;
            }

            let html = '';

            // Show currently playing
            if (currentlyPlaying) {
                html += `
                    <div class="queue-item playing">
                        <div class="queue-number">‚ñ∂</div>
                        <div class="queue-filename">${currentlyPlaying.filename}</div>
                    </div>
                `;
            }

            // Show queued items
            audioQueue.forEach((item, index) => {
                html += `
                    <div class="queue-item">
                        <div class="queue-number">${index + 1}</div>
                        <div class="queue-filename">${item.filename}</div>
                    </div>
                `;
            });

            container.innerHTML = html;
            updateStats();
        }

        function playNextAudio(retryCount = 0, failedAudio = null) {
            // If retrying, put the failed audio back at the front of the queue
            if (failedAudio && retryCount > 0 && retryCount < 3) {
                audioQueue.unshift(failedAudio);
            }

            if (audioQueue.length === 0) {
                isPlaying = false;
                currentlyPlaying = null;
                if (audioPlayer) {
                    audioPlayer = null;
                }
                updateQueue();
                addAudioLog('Queue empty - playback stopped', 'info');
                return;
            }

            isPlaying = true;
            const nextAudio = audioQueue.shift();
            currentlyPlaying = nextAudio;
            updateQueue();

            // Clean up previous player
            if (audioPlayer) {
                audioPlayer.pause();
                audioPlayer.src = '';
            }

            audioPlayer = new Audio(nextAudio.url);

            // Event: Audio ended successfully
            audioPlayer.addEventListener('ended', () => {
                addAudioLog(`‚úì Finished: ${nextAudio.filename}`, 'tts-success');
                socket.emit('audio_ended', { filename: nextAudio.filename });
                stats.played++;
                updateStats();

                // Play next
                playNextAudio(0, null);
            });

            // Event: Audio error
            audioPlayer.addEventListener('error', (e) => {
                let errorDetail = 'Unknown error';
                if (audioPlayer.error) {
                    switch(audioPlayer.error.code) {
                        case 1: errorDetail = 'Audio loading aborted'; break;
                        case 2: errorDetail = 'Network error'; break;
                        case 3: errorDetail = 'Audio decoding failed'; break;
                        case 4: errorDetail = 'Audio format not supported'; break;
                    }
                }

                console.error('Audio playback error:', {
                    filename: nextAudio.filename,
                    error: e,
                    errorDetail: errorDetail,
                    retryCount: retryCount
                });

                socket.emit('audio_error', {
                    filename: nextAudio.filename,
                    error: errorDetail,
                    retryCount: retryCount
                });

                // Retry up to 3 times
                if (retryCount < 3) {
                    const retryDelay = Math.pow(2, retryCount) * 500;
                    addAudioLog(`‚ö† Error: ${errorDetail}. Retrying ${nextAudio.filename} in ${retryDelay/1000}s (attempt ${retryCount + 1}/3)`, 'tts-error');
                    stats.errors++;
                    updateStats();
                    setTimeout(() => {
                        playNextAudio(retryCount + 1, nextAudio);
                    }, retryDelay);
                } else {
                    addAudioLog(`‚úó Failed: ${nextAudio.filename} after 3 attempts (${errorDetail}). Skipping...`, 'tts-error');
                    stats.errors++;
                    updateStats();
                    // Skip to next
                    setTimeout(() => {
                        playNextAudio(0, null);
                    }, 1000);
                }
            });

            // Start playback
            audioPlayer.play()
                .then(() => {
                    addAudioLog(`‚ñ∂ Playing: ${nextAudio.filename}`, 'audio-playing');
                    socket.emit('audio_playing', {
                        filename: nextAudio.filename,
                        url: nextAudio.url
                    });
                })
                .catch(error => {
                    console.error('Error starting playback:', error);

                    socket.emit('audio_error', {
                        filename: nextAudio.filename,
                        error: 'Failed to start playback: ' + error.message,
                        retryCount: retryCount
                    });

                    // Retry or skip
                    if (retryCount < 3) {
                        const retryDelay = Math.pow(2, retryCount) * 500;
                        addAudioLog(`‚ö† Failed to start: ${nextAudio.filename}. Retrying in ${retryDelay/1000}s (attempt ${retryCount + 1}/3)`, 'tts-error');
                        stats.errors++;
                        updateStats();
                        setTimeout(() => {
                            playNextAudio(retryCount + 1, nextAudio);
                        }, retryDelay);
                    } else {
                        addAudioLog(`‚úó Cannot play: ${nextAudio.filename} after 3 attempts. Skipping...`, 'tts-error');
                        stats.errors++;
                        updateStats();
                        setTimeout(() => {
                            playNextAudio(0, null);
                        }, 1000);
                    }
                });
        }

        function queueAudio(dialogId, filename) {
            const audioUrl = `/audio/${dialogId}/${filename}`;

            audioQueue.push({
                filename: filename,
                url: audioUrl,
                dialogId: dialogId
            });

            addAudioLog(`Queued: ${filename}`, 'audio-queued');
            updateQueue();

            // Emit queued event
            socket.emit('audio_queued', {
                filename: filename,
                url: audioUrl,
                queueLength: audioQueue.length
            });

            // Start playing if not already playing and auto-play is enabled
            if (!isPlaying && autoPlayEnabled) {
                playNextAudio();
            }
        }

        function addTTSLog(message, type = 'info') {
            const timestamp = new Date().toLocaleTimeString();
            const logEntry = {
                timestamp,
                message,
                type
            };

            ttsLogs.unshift(logEntry);
            if (ttsLogs.length > 100) ttsLogs.pop();

            updateTTSLog();
        }

        function addAudioLog(message, type = 'info') {
            const timestamp = new Date().toLocaleTimeString();
            const logEntry = {
                timestamp,
                message,
                type
            };

            audioLogs.unshift(logEntry);
            if (audioLogs.length > 100) audioLogs.pop();

            updateAudioLog();
        }

        function updateTTSLog() {
            const container = document.getElementById('ttsLog');

            if (ttsLogs.length === 0) {
                container.innerHTML = '<div class="empty-state">No TTS activity yet</div>';
                return;
            }

            const html = ttsLogs.map(log => `
                <div class="log-entry ${log.type}">
                    <span class="timestamp">${log.timestamp}</span>
                    ${log.message}
                </div>
            `).join('');

            container.innerHTML = html;
        }

        function updateAudioLog() {
            const container = document.getElementById('audioLog');

            if (audioLogs.length === 0) {
                container.innerHTML = '<div class="empty-state">No audio playback yet</div>';
                return;
            }

            const html = audioLogs.map(log => `
                <div class="log-entry ${log.type}">
                    <span class="timestamp">${log.timestamp}</span>
                    ${log.message}
                </div>
            `).join('');

            container.innerHTML = html;
        }

        function clearQueue() {
            // Stop current playback
            if (audioPlayer) {
                audioPlayer.pause();
                audioPlayer.src = '';
                audioPlayer = null;
            }

            // Clear queue
            audioQueue = [];
            currentlyPlaying = null;
            isPlaying = false;

            updateQueue();
            updateStats();
            addAudioLog('Queue cleared and playback stopped', 'info');
        }

        function clearLogs() {
            ttsLogs = [];
            audioLogs = [];
            updateTTSLog();
            updateAudioLog();
        }

        function toggleAutoPlay() {
            autoPlayEnabled = document.getElementById('autoPlayToggle').checked;
            addAudioLog(`Auto-play ${autoPlayEnabled ? 'enabled' : 'disabled'}`, 'info');

            // If enabling and there's queue but not playing, start playing
            if (autoPlayEnabled && !isPlaying && audioQueue.length > 0) {
                playNextAudio();
            }
        }

        function addDialogTurn(speaker, turn, type) {
            const turnKey = `${turn}_${speaker}`;
            const turnData = {
                turn: turn,
                speaker: speaker,
                type: type,
                timestamp: new Date().toLocaleTimeString(),
                ttsStatus: 'pending'
            };

            dialogTurns.push(turnData);
            turnTTSStatus[turnKey] = turnData;
            updateTurnTracker();
        }

        function updateTurnTTSStatus(speaker, turn, status, details = '') {
            const turnKey = `${turn}_${speaker}`;
            if (turnTTSStatus[turnKey]) {
                turnTTSStatus[turnKey].ttsStatus = status;
                turnTTSStatus[turnKey].ttsDetails = details;
                updateTurnTracker();
            }
        }

        function updateTurnTracker() {
            const container = document.getElementById('turnTracker');

            if (dialogTurns.length === 0) {
                container.innerHTML = '<div class="empty-state">No dialog turns yet</div>';
                return;
            }

            const html = dialogTurns.map((turn, index) => {
                let statusIcon = '‚è≥';
                let statusColor = '#ffc000';
                let statusText = 'Waiting';

                if (turn.ttsStatus === 'started') {
                    statusIcon = 'üé§';
                    statusColor = '#4472c4';
                    statusText = 'Generating TTS...';
                } else if (turn.ttsStatus === 'complete') {
                    statusIcon = '‚úì';
                    statusColor = '#70ad47';
                    statusText = 'TTS Ready';
                } else if (turn.ttsStatus === 'error') {
                    statusIcon = '‚úó';
                    statusColor = '#c55a11';
                    statusText = 'TTS Error';
                } else if (turn.ttsStatus === 'skipped') {
                    statusIcon = '‚äò';
                    statusColor = '#808080';
                    statusText = 'Skipped (TTS disabled)';
                }

                const details = turn.ttsDetails ? `<br><span style="font-size:10px; color:#808080;">${turn.ttsDetails}</span>` : '';

                return `
                    <div class="log-entry" style="border-left-color: ${statusColor};">
                        <span class="timestamp">${turn.timestamp}</span>
                        <strong>Turn ${turn.turn}</strong> - ${turn.speaker} (${turn.type})
                        <span style="margin-left: 10px; color: ${statusColor};">${statusIcon} ${statusText}</span>
                        ${details}
                    </div>
                `;
            }).join('');

            container.innerHTML = html;
        }

        // Socket event listeners
        socket.on('connect', () => {
            addTTSLog('Connected to server', 'tts-success');
            addAudioLog('Connected to server', 'audio-playing');
        });

        socket.on('dialog_update', (data) => {
            // Track all dialog turns
            if (data.type === 'intermediator_response' || data.type === 'participant1_response' || data.type === 'participant2_response') {
                addDialogTurn(data.speaker, data.turn || 0, data.type);
            }
        });

        socket.on('tts_start', (data) => {
            const details = `${data.speaker} Turn ${data.turn} | ${data.text_length} chars | Voice: ${data.voice}`;
            const preview = data.text_preview ? `<br><span style="color:#808080; font-size:11px;">"${data.text_preview}"</span>` : '';
            addTTSLog(`üé§ TTS START: ${details}${preview}`, 'tts-start');

            // Update turn tracker
            updateTurnTTSStatus(data.speaker, data.turn, 'started', `${data.text_length} chars, voice: ${data.voice}`);
        });

        socket.on('tts_complete', (data) => {
            stats.generated++;
            updateStats();
            const sizeKB = (data.file_size / 1024).toFixed(1);
            const truncated = data.was_truncated ? ' [TRUNCATED]' : '';
            const details = `${data.filename} | ${sizeKB} KB | ${data.text_length} chars${truncated}`;
            addTTSLog(`‚úì TTS COMPLETE: ${details}`, 'tts-success');

            // Update turn tracker
            updateTurnTTSStatus(data.speaker, data.turn, 'complete', `${sizeKB} KB${truncated}`);
        });

        socket.on('tts_error', (data) => {
            stats.errors++;
            updateStats();
            addTTSLog(`‚úó Error: ${data.error}`, 'tts-error');

            // Update turn tracker
            updateTurnTTSStatus(data.speaker, data.turn, 'error', data.error);
        });

        socket.on('audio_ready', (data) => {
            addTTSLog(`Audio file ready: ${data.filename}`, 'tts-success');
            // Queue the audio for playback
            queueAudio(data.dialog_id, data.filename);
        });

        socket.on('debug_log', (data) => {
            // Display debug logs in the TTS log for visibility
            let message = data.message;
            if (data.server) {
                message = `[${data.server}] ${message}`;
            }
            const type = data.level === 'error' ? 'tts-error' : 'debug-log';
            addTTSLog(message, type);
        });

        // Initialize
        updateStats();
        updateQueue();
    </script>
</body>
</html>
