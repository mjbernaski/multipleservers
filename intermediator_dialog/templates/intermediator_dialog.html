<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Intermediated Dialog (IDi)</title>
    <script src="https://cdn.socket.io/4.5.4/socket.io.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            background: #ffffff;
            padding: 15px;
            color: #000000;
            transition: background-color 0.3s ease, color 0.3s ease;
        }

        body.dark-mode {
            background: #1a1a1a;
            color: #e0e0e0;
        }

        .container {
            max-width: 1600px;
            margin: 0 auto;
            padding-bottom: 60px;
            /* Space for status bar */
        }

        h1 {
            text-align: center;
            color: #1f4e78;
            margin-bottom: 12px;
            font-weight: 600;
            letter-spacing: -0.5px;
            font-size: 28px;
            transition: color 0.3s ease;
        }

        body.dark-mode h1 {
            color: #6ba3d8;
        }

        .controls {
            background: #ffffff;
            padding: 10px;
            border-radius: 8px;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
            margin-bottom: 15px;
            border: 1px solid #d0d0d0;
            transition: background-color 0.3s ease, border-color 0.3s ease;
        }

        body.dark-mode .controls {
            background: #2d2d2d;
            border-color: #404040;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
        }

        .form-group {
            margin-bottom: 8px;
        }

        label {
            display: block;
            margin-bottom: 4px;
            font-weight: 500;
            color: #1f4e78;
            font-size: 13px;
            transition: color 0.3s ease;
        }

        body.dark-mode label {
            color: #6ba3d8;
        }

        input[type="text"],
        textarea,
        select {
            width: 100%;
            padding: 7px 10px;
            border: 1px solid #d0d0d0;
            border-radius: 4px;
            font-size: 13px;
            background: #ffffff;
            color: #000000;
            transition: border-color 0.2s, background-color 0.3s ease, color 0.3s ease;
        }

        body.dark-mode input[type="text"],
        body.dark-mode textarea,
        body.dark-mode select {
            background: #1a1a1a;
            color: #e0e0e0;
            border-color: #404040;
        }

        input[type="text"]:focus,
        textarea:focus,
        select:focus {
            outline: none;
            border-color: #4472c4;
            box-shadow: 0 0 0 2px rgba(68, 114, 196, 0.1);
        }

        textarea {
            min-height: 60px;
            resize: vertical;
        }

        textarea.short {
            min-height: 45px;
        }

        button {
            background: #4472c4;
            color: #ffffff;
            border: none;
            padding: 8px 16px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 500;
            transition: all 0.2s;
            box-shadow: 0 2px 4px rgba(68, 114, 196, 0.2);
        }

        button.primary {
            padding: 10px 20px;
            font-size: 15px;
        }

        button.secondary {
            background: #70ad47;
        }

        button.utility {
            padding: 6px 12px;
            font-size: 13px;
            background: #808080;
        }

        button:hover {
            background: #365899;
            box-shadow: 0 3px 6px rgba(68, 114, 196, 0.3);
            transform: translateY(-1px);
        }

        button:disabled {
            background: #d0d0d0;
            color: #808080;
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }

        .status {
            margin-top: 10px;
            padding: 12px 16px;
            border-radius: 4px;
            display: none;
            font-size: 14px;
        }

        .status.info {
            background: #dae3f3;
            color: #1f4e78;
            border: 1px solid #8db4e2;
        }

        .status.error {
            background: #fce4d6;
            color: #c55a11;
            border: 1px solid #f4b084;
        }

        .status.success {
            background: #e2efda;
            color: #70ad47;
            border: 1px solid #a9d08e;
        }

        .ai-config {
            display: grid;
            grid-template-columns: 1fr 1fr 1fr;
            gap: 12px;
            margin-bottom: 12px;
        }

        @media (max-width: 1200px) {
            .ai-config {
                grid-template-columns: 1fr;
            }
        }

        .ai-config-row {
            display: grid;
            grid-template-columns: 2fr 3fr;
            gap: 8px;
            align-items: end;
        }

        .ai-config-row label {
            margin-bottom: 2px;
        }

        .ai-panel {
            background: #f2f2f2;
            padding: 10px;
            border-radius: 6px;
            border: 1px solid #d0d0d0;
            transition: background-color 0.3s ease, border-color 0.3s ease;
        }

        body.dark-mode .ai-panel {
            background: #252525;
            border-color: #404040;
        }

        /* Utility classes */
        .flex-between {
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .flex-center {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .text-muted {
            color: #808080;
            font-size: 11px;
        }

        .compact-card {
            padding: 8px;
            border-radius: 4px;
        }

        .ai-panel.intermediator {
            border-left: 4px solid #4472c4;
        }

        .ai-panel.participant1 {
            border-left: 4px solid #70ad47;
        }

        .ai-panel.participant2 {
            border-left: 4px solid #c55a11;
        }

        .ai-panel-title {
            font-weight: 600;
            margin-bottom: 8px;
            color: #1f4e78;
            font-size: 14px;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        body.dark-mode .ai-panel-title {
            color: #6ba3d8;
        }

        .status-indicator {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            display: inline-block;
            flex-shrink: 0;
            margin-right: 4px;
        }

        .status-indicator.online {
            background: #70ad47;
            box-shadow: 0 0 6px rgba(112, 173, 71, 0.5);
        }

        .status-indicator.offline {
            background: #c55a11;
            box-shadow: 0 0 4px rgba(197, 90, 17, 0.4);
        }

        .status-indicator.checking {
            background: #ffc000;
            animation: pulse 1.5s ease-in-out infinite;
        }

        @keyframes pulse {

            0%,
            100% {
                opacity: 1;
            }

            50% {
                opacity: 0.5;
            }
        }

        .status-text {
            font-size: 11px;
            font-weight: 500;
            margin-left: 4px;
        }

        .status-text.online {
            color: #70ad47;
        }

        .status-text.offline {
            color: #c55a11;
        }

        .status-text.checking {
            color: #ffc000;
        }

        .dialog-container {
            background: #ffffff;
            border-radius: 8px;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
            overflow: hidden;
            border: 1px solid #d0d0d0;
            transition: background-color 0.3s ease, border-color 0.3s ease;
            max-height: calc(80vh - 60px);
            /* Account for status bar */
            overflow-y: auto;
        }

        body.dark-mode .dialog-container {
            background: #2d2d2d;
            border-color: #404040;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
        }

        .dialog-turn {
            padding: 16px 20px;
            border-bottom: 1px solid #d0d0d0;
            transition: background-color 0.3s ease, border-color 0.3s ease;
        }

        body.dark-mode .dialog-turn {
            border-bottom-color: #404040;
        }

        .dialog-turn:last-child {
            border-bottom: none;
        }

        .dialog-turn.intermediator {
            background: #dae3f3;
            border-left: 4px solid #4472c4;
        }

        body.dark-mode .dialog-turn.intermediator {
            background: #2a3441;
        }

        .dialog-turn.intermediator.summary {
            background: #e7f3ff;
            border-left: 4px solid #1f4e78;
            border-top: 2px solid #4472c4;
        }

        body.dark-mode .dialog-turn.intermediator.summary {
            background: #1a2a3a;
        }

        .dialog-turn.participant1 {
            background: #e2efda;
            border-left: 4px solid #70ad47;
        }

        body.dark-mode .dialog-turn.participant1 {
            background: #2d3528;
        }

        .dialog-turn.participant2 {
            background: #fce4d6;
            border-left: 4px solid #c55a11;
        }

        body.dark-mode .dialog-turn.participant2 {
            background: #3d2f28;
        }

        .turn-header {
            font-weight: 600;
            margin-bottom: 8px;
            font-size: 14px;
        }

        .turn-header.intermediator {
            color: #1f4e78;
        }

        body.dark-mode .turn-header.intermediator {
            color: #6ba3d8;
        }

        .turn-header.participant1 {
            color: #548235;
        }

        .turn-header.participant2 {
            color: #833c0c;
        }

        .turn-content {
            white-space: pre-wrap;
            line-height: 1.7;
            color: #000000;
        }

        body.dark-mode .turn-content {
            color: #e0e0e0;
        }

        .turn-content.streaming {
            background: #fff2cc;
            padding: 8px;
            border-radius: 4px;
        }

        body.dark-mode .turn-content.streaming {
            background: #3d3520;
        }

        .tokens {
            margin-top: 8px;
            font-size: 11px;
            color: #808080;
            font-style: italic;
        }

        .loading {
            text-align: center;
            padding: 40px;
            color: #808080;
        }

        .spinner {
            border: 3px solid #d0d0d0;
            border-top: 3px solid #4472c4;
            border-radius: 50%;
            width: 30px;
            height: 30px;
            animation: spin 1s linear infinite;
            margin: 0 auto 10px;
        }

        @keyframes spin {
            0% {
                transform: rotate(0deg);
            }

            100% {
                transform: rotate(360deg);
            }
        }

        .status-bar {
            position: fixed;
            bottom: 0;
            left: 0;
            right: 0;
            background: #1f4e78;
            color: #ffffff;
            padding: 12px 20px;
            font-size: 14px;
            font-weight: 500;
            box-shadow: 0 -2px 8px rgba(0, 0, 0, 0.2);
            z-index: 1000;
            display: flex;
            align-items: center;
            gap: 12px;
            transition: background-color 0.3s ease;
        }

        body.dark-mode .status-bar {
            background: #2d4a6b;
        }

        .status-bar.intermediator {
            background: #4472c4;
        }

        body.dark-mode .status-bar.intermediator {
            background: #365899;
        }

        .status-bar.participant1 {
            background: #70ad47;
        }

        body.dark-mode .status-bar.participant1 {
            background: #548235;
        }

        .status-bar.participant2 {
            background: #c55a11;
        }

        body.dark-mode .status-bar.participant2 {
            background: #833c0c;
        }

        .status-bar.idle {
            background: #808080;
        }

        body.dark-mode .status-bar.idle {
            background: #555555;
        }

        /* Dark mode support for inline-styled elements */
        body.dark-mode select,
        body.dark-mode #debateList,
        body.dark-mode #saveToLibraryModal>div,
        body.dark-mode #saveToLibraryModal input,
        body.dark-mode #saveToLibraryModal textarea {
            background: #2a2a2a !important;
            color: #e0e0e0 !important;
            border-color: #444444 !important;
        }

        body.dark-mode #saveToLibraryModal h3,
        body.dark-mode #saveToLibraryModal label {
            color: #7bb3ff !important;
        }

        body.dark-mode [style*="background: #ffffff"],
        body.dark-mode [style*="background:#ffffff"] {
            background: #2a2a2a !important;
        }

        body.dark-mode [style*="color: #1f4e78"],
        body.dark-mode [style*="color:#1f4e78"] {
            color: #7bb3ff !important;
        }

        body.dark-mode [style*="color: #808080"],
        body.dark-mode [style*="color:#808080"] {
            color: #b0b0b0 !important;
        }

        body.dark-mode #debateList>div {
            background: #2a2a2a !important;
            border-color: #444444 !important;
        }

        body.dark-mode #debateList>div:hover {
            background: #1f3a52 !important;
        }

        body.dark-mode #summaryProgressSection {
            background: #1f3a52 !important;
            border-color: #4472c4 !important;
        }

        body.dark-mode #argumentDiagramsSection,
        body.dark-mode #gpuMonitoringSection {
            background: #2a2a2a !important;
            border-color: #444444 !important;
        }

        body.dark-mode #argumentDiagramsSection h3,
        body.dark-mode #gpuMonitoringSection h3 {
            color: #7bb3ff !important;
        }

        body.dark-mode [style*="background: #f5f0ff"] {
            background: #3a2a4a !important;
        }

        body.dark-mode [style*="color: #9d60d6"] {
            color: #c084fc !important;
        }

        /* Additional dark mode overrides for common inline styles */
        body.dark-mode [style*="background: #f9f9f9"],
        body.dark-mode [style*="background:#f9f9f9"] {
            background: #2a2a2a !important;
        }

        body.dark-mode [style*="background: #f2f2f2"],
        body.dark-mode [style*="background:#f2f2f2"] {
            background: #2a2a2a !important;
        }

        body.dark-mode [style*="background: #e7f3ff"],
        body.dark-mode [style*="background:#e7f3ff"] {
            background: #1a2a3a !important;
        }

        body.dark-mode [style*="color: #000000"],
        body.dark-mode [style*="color:#000000"] {
            color: #e0e0e0 !important;
        }

        body.dark-mode [style*="border: 1px solid #d0d0d0"],
        body.dark-mode [style*="border:1px solid #d0d0d0"],
        body.dark-mode [style*="border-top: 1px solid #d0d0d0"],
        body.dark-mode [style*="border-top:1px solid #d0d0d0"],
        body.dark-mode [style*="border-bottom: 1px solid #d0d0d0"],
        body.dark-mode [style*="border-bottom:1px solid #d0d0d0"] {
            border-color: #404040 !important;
        }

        /* Dark mode for buttons */
        body.dark-mode button[style*="background: #70ad47"]:hover {
            background: #548235 !important;
        }

        body.dark-mode button[style*="background: #4472c4"]:hover {
            background: #365899 !important;
        }

        body.dark-mode button[style*="background: #808080"]:hover {
            background: #666666 !important;
        }

        body.dark-mode button[style*="background: #c55a11"]:hover {
            background: #833c0c !important;
        }

        /* Dark mode for form elements with inline styles */
        body.dark-mode input[style*="background: #ffffff"],
        body.dark-mode input[style*="background:#ffffff"],
        body.dark-mode select[style*="background: #ffffff"],
        body.dark-mode select[style*="background:#ffffff"],
        body.dark-mode textarea[style*="background: #ffffff"],
        body.dark-mode textarea[style*="background:#ffffff"] {
            background: #1a1a1a !important;
            color: #e0e0e0 !important;
        }

        /* Dark mode for debate queue section */
        body.dark-mode #debateQueueProgress {
            background: #1a2a3a !important;
            border-color: #4472c4 !important;
        }

        body.dark-mode #debateQueueProgress [style*="background: #ffffff"],
        body.dark-mode #debateQueueProgress [style*="background:#ffffff"] {
            background: #2a2a2a !important;
        }

        body.dark-mode #debateQueueProgress [style*="color: #4472c4"],
        body.dark-mode #debateQueueProgress [style*="color:#4472c4"] {
            color: #7bb3ff !important;
        }

        body.dark-mode #debateQueueProgress [style*="color: #70ad47"],
        body.dark-mode #debateQueueProgress [style*="color:#70ad47"] {
            color: #8fcc66 !important;
        }

        /* Dark mode for PDF export section */
        body.dark-mode #pdfExportSection {
            background: #2a2a2a !important;
            border-color: #404040 !important;
        }

        /* Dark mode for file info */
        body.dark-mode .text-muted,
        body.dark-mode #fileInfo {
            color: #b0b0b0 !important;
        }

        /* Dark mode for shared spark model section */
        body.dark-mode [style*="background: #f2f2f2"][style*="padding: 12px"] {
            background: #2a2a2a !important;
            border-color: #404040 !important;
        }

        /* Dark mode for debate library section */
        body.dark-mode #debateLibrarySection [style*="background: #f9f9f9"] {
            background: #2a2a2a !important;
            border-color: #404040 !important;
        }

        /* Dark mode for checkbox container */
        body.dark-mode .flex-center[style*="background: #f9f9f9"] {
            background: #2a2a2a !important;
            border-color: #404040 !important;
        }

        /* Dark mode for status messages */
        body.dark-mode .status-message {
            color: #e0e0e0 !important;
        }

        /* Dark mode for all divs with white backgrounds */
        body.dark-mode div[style*="background: #ffffff"]:not(.dialog-turn):not(.status-bar),
        body.dark-mode div[style*="background:#ffffff"]:not(.dialog-turn):not(.status-bar) {
            background: #2a2a2a !important;
        }

        /* Dark mode for spans with specific colors */
        body.dark-mode span[style*="color: #808080"] {
            color: #b0b0b0 !important;
        }

        /* Dark mode for loading text */
        body.dark-mode [style*="color: #808080"][style*="text-align: center"] {
            color: #b0b0b0 !important;
        }

        .status-bar-indicator {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            background: #ffffff;
            box-shadow: 0 0 8px rgba(255, 255, 255, 0.5);
            animation: pulse 2s ease-in-out infinite;
        }

        @keyframes pulse {

            0%,
            100% {
                opacity: 1;
                transform: scale(1);
            }

            50% {
                opacity: 0.7;
                transform: scale(1.1);
            }
        }

        .status-bar-content {
            flex: 1;
        }

        .status-bar-turn {
            font-size: 12px;
            opacity: 0.9;
            margin-left: 8px;
        }
    </style>
</head>

<body>
    <div class="container">
        <div class="flex-between" style="margin-bottom: 10px;">
            <h1 style="margin: 0; font-size: 24px;">Intermediated Dialog <span
                    style="font-size: 16px; color: #808080; font-weight: 400;">(IDi)</span> <span
                    style="font-size: 11px; color: #9d60d6; font-weight: 500; background: #f5f0ff; padding: 2px 6px; border-radius: 3px; margin-left: 6px;">v1.6.2</span>
            </h1>
            <div class="flex-center" style="gap: 6px;">
                <input type="checkbox" id="enableTTS" onchange="toggleAudioGeneration()">
                <label for="enableTTS" class="utility"
                    style="background: #70ad47; cursor: pointer; display: flex; align-items: center; justify-content: center; width: 30px; height: 30px; border-radius: 4px;">
                    üîä
                </label>
                <button id="darkModeToggle" onclick="toggleDarkMode()" class="utility" style="background: #4472c4;">
                    üåô
                </button>
            </div>
        </div>

        <div class="controls">
            <div class="ai-config">
                <div class="ai-panel intermediator">
                    <div class="ai-panel-title">
                        <span class="status-indicator checking" id="intermediator-status-indicator"></span>
                        <span>Intermediator (Moderator)</span>
                        <span class="status-text checking" id="intermediator-status-text"
                            style="margin-left: auto;">Checking...</span>
                    </div>
                    <div class="form-group">
                        <label for="intermediator-host">Host:</label>
                        <input type="text" id="intermediator-host" value="http://192.168.6.40:11434"
                            placeholder="http://host:port"
                            onchange="checkServerStatus('intermediator'); loadModels('intermediator')">
                    </div>
                    <div class="form-group">
                        <label for="intermediator-model">Model:</label>
                        <select id="intermediator-model" onchange="checkServerStatus('intermediator')"
                            style="width: 100%; padding: 7px 10px; border: 1px solid #d0d0d0; border-radius: 4px; font-size: 13px; background: #ffffff; color: #000000;">
                            <option value="gpt-oss:20b" selected>Loading models...</option>
                        </select>
                    </div>
                    <div class="form-group">
                        <label for="intermediator-name">Name:</label>
                        <input type="text" id="intermediator-name" value="RT5090" placeholder="Display name">
                    </div>
                </div>

                <div class="ai-panel participant1">
                    <div class="ai-panel-title">
                        <span class="status-indicator checking" id="participant1-status-indicator"></span>
                        <span>Participant A (Spark 1)</span>
                        <span class="status-text checking" id="participant1-status-text"
                            style="margin-left: auto;">Checking...</span>
                    </div>
                    <div class="form-group">
                        <label for="participant1-host">Host:</label>
                        <input type="text" id="participant1-host" value="http://192.168.5.40:11434"
                            placeholder="http://host:port"
                            onchange="checkServerStatus('participant1'); loadModels('participant1')">
                    </div>
                    <div class="form-group">
                        <label style="display: flex; align-items: center; gap: 8px;">
                            <input type="checkbox" id="participant1-override-model" onchange="toggleParticipant1Model()"
                                style="width: auto;">
                            <span>Override shared model</span>
                        </label>
                        <select id="participant1-model"
                            style="margin-top: 4px; width: 100%; padding: 7px 10px; border: 1px solid #d0d0d0; border-radius: 4px; font-size: 13px; background: #ffffff; color: #000000;"
                            disabled onchange="checkServerStatus('participant1')">
                            <option value="gpt-oss:20b" selected>Loading models...</option>
                        </select>
                    </div>
                    <div class="form-group">
                        <label for="participant1-name">Name:</label>
                        <input type="text" id="participant1-name" value="NVIDIA DGX Spark A" placeholder="Display name">
                    </div>
                </div>

                <div class="ai-panel participant2">
                    <div class="ai-panel-title">
                        <span class="status-indicator checking" id="participant2-status-indicator"></span>
                        <span>Participant B (Spark 2)</span>
                        <span class="status-text checking" id="participant2-status-text"
                            style="margin-left: auto;">Checking...</span>
                    </div>
                    <div class="form-group">
                        <label for="participant2-host">Host:</label>
                        <input type="text" id="participant2-host" value="http://192.168.5.46:11434"
                            placeholder="http://host:port"
                            onchange="checkServerStatus('participant2'); loadModels('participant2')">
                    </div>
                    <div class="form-group">
                        <label style="display: flex; align-items: center; gap: 8px;">
                            <input type="checkbox" id="participant2-override-model" onchange="toggleParticipant2Model()"
                                style="width: auto;">
                            <span>Override shared model</span>
                        </label>
                        <select id="participant2-model"
                            style="margin-top: 4px; width: 100%; padding: 7px 10px; border: 1px solid #d0d0d0; border-radius: 4px; font-size: 13px; background: #ffffff; color: #000000;"
                            disabled onchange="checkServerStatus('participant2')">
                            <option value="gpt-oss:120b" selected>Loading models...</option>
                        </select>
                    </div>
                    <div class="form-group">
                        <label for="participant2-name">Name:</label>
                        <input type="text" id="participant2-name" value="NVIDIA DGX Spark B" placeholder="Display name">
                    </div>
                </div>
            </div>

            <div class="form-group"
                style="background: #f2f2f2; padding: 12px; border-radius: 6px; margin-top: 12px; border: 1px solid #d0d0d0;">
                <label for="shared-spark-model" style="font-weight: 600; color: #1f4e78;">Shared Model for Spark
                    Servers:</label>
                <select id="shared-spark-model" onchange="updateSharedModel()"
                    style="width: 100%; padding: 7px 10px; border: 1px solid #d0d0d0; border-radius: 4px; font-size: 13px; background: #ffffff; color: #000000;">
                    <option value="gpt-oss:20b" selected>gpt-oss:20b</option>
                </select>
                <div style="font-size: 11px; color: #808080; margin-top: 4px;">This model will be used for both Spark
                    servers unless overridden individually. Models will be populated when servers are checked.</div>
            </div>

            <div class="form-group" style="border-top: 1px solid #d0d0d0; padding-top: 12px; margin-top: 12px;">
                <div style="display: flex; align-items: center; justify-content: space-between; margin-bottom: 8px;">
                    <label
                        style="display: flex; align-items: center; cursor: pointer; font-weight: 600; color: #1f4e78; font-size: 13px; margin: 0;"
                        onclick="togglePromptConfig()">
                        <span id="promptConfigToggle" style="margin-right: 8px; font-size: 13px;">‚ñº</span>
                        <span>Prompt Configuration</span>
                    </label>
                    <button onclick="resetPromptsToDefaults()" class="utility"
                        style="background: #4472c4; padding: 4px 12px; font-size: 11px;"
                        title="Reset pre/post prompts to current defaults">üîÑ Reset Prompts</button>
                </div>

                <div id="promptConfigSection" style="display: block;">
                    <div class="form-group">
                        <label for="intermediator-pre-prompt">Intermediator Pre-Prompt (static):</label>
                        <textarea id="intermediator-pre-prompt"
                            placeholder="Static pre-prompt for the intermediator that stays the same across dialogs..."></textarea>
                    </div>

                    <div class="form-group">
                        <label for="intermediator-topic-prompt">Intermediator Topic/Instructions Prompt <span
                                style="color: #c55a11;">*</span>:</label>
                        <textarea id="intermediator-topic-prompt"
                            placeholder="Dynamic prompt that frames the specific topic and instructions for this dialog. This is required and replaces the separate topic field."
                            required></textarea>
                        <div style="font-size: 11px; color: #808080; margin-top: 4px;">Required: Include the topic and
                            any specific instructions here. This will be combined with the pre-prompt (if provided) to
                            form the intermediator's system prompt.</div>
                    </div>

                    <div class="form-group">
                        <label for="participant-pre-prompt">Participant Pre-Prompt (shared):</label>
                        <textarea id="participant-pre-prompt"
                            placeholder="Shared prompt that appears before the mid-prompt for both participants..."></textarea>
                    </div>

                    <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 16px;">
                        <div class="form-group">
                            <label for="participant1-mid-prompt">Participant 1 Mid-Prompt:</label>
                            <textarea id="participant1-mid-prompt"
                                placeholder="Custom prompt for Participant 1 (Spark 1)..."></textarea>
                        </div>
                        <div class="form-group">
                            <label for="participant2-mid-prompt">Participant 2 Mid-Prompt:</label>
                            <textarea id="participant2-mid-prompt"
                                placeholder="Custom prompt for Participant 2 (Spark 2)..."></textarea>
                        </div>
                    </div>

                    <div class="form-group">
                        <label for="participant-post-prompt">Participant Post-Prompt (shared):</label>
                        <textarea id="participant-post-prompt"
                            placeholder="Shared prompt that appears after the mid-prompt for both participants..."></textarea>
                    </div>

                    <div style="font-size: 11px; color: #808080; margin-top: 8px;">
                        <strong>Prompt Structure:</strong><br>
                        Intermediator: pre-prompt (static) + topic/instructions prompt (dynamic)<br>
                        Participants: pre-prompt (shared) + [mid-prompt (custom per server)] + post-prompt (shared)
                    </div>
                </div>
            </div>

            <div class="form-group" style="border-top: 1px solid #d0d0d0; padding-top: 12px; margin-top: 12px;">
                <label
                    style="display: flex; align-items: center; cursor: pointer; font-weight: 600; color: #1f4e78; margin-bottom: 8px; font-size: 13px;"
                    onclick="toggleDebateLibrary()">
                    <span id="debateLibraryToggle" style="margin-right: 8px; font-size: 13px;">‚ñ∂</span>
                    <span id="debateLibraryCount">Debate Library (loading...)</span>
                </label>

                <div id="debateLibrarySection" style="display: none;">
                    <div
                        style="margin-bottom: 12px; padding: 10px; background: #f9f9f9; border-radius: 4px; border: 1px solid #d0d0d0;">
                        <div style="display: flex; gap: 8px; margin-bottom: 8px; flex-wrap: wrap;">
                            <button onclick="selectAllDebates()"
                                style="background: #70ad47; padding: 6px 12px; font-size: 12px;">Select All</button>
                            <button onclick="deselectAllDebates()"
                                style="background: #808080; padding: 6px 12px; font-size: 12px;">Deselect All</button>
                            <button onclick="loadSelectedDebates()"
                                style="background: #4472c4; padding: 6px 12px; font-size: 12px;">‚ñ∂ Load & Run
                                Selected</button>
                        </div>
                        <div id="debateSelectionCount" style="font-size: 12px; color: #808080; font-style: italic;">0
                            debates selected</div>
                    </div>

                    <div id="debateList"
                        style="max-height: 400px; overflow-y: auto; border: 1px solid #d0d0d0; border-radius: 4px; padding: 8px; background: #ffffff;">
                        <div style="text-align: center; padding: 20px; color: #808080;">Loading debates...</div>
                    </div>
                </div>
            </div>

            <div class="form-group">
                <div style="display: flex; align-items: center; gap: 16px; flex-wrap: wrap;">
                    <div class="flex-center">
                        <label for="fileUpload" style="margin: 0; font-size: 12px;">Context File:</label>
                        <input type="file" id="fileUpload" accept=".txt,.md,.log,.json" onchange="updateFileInfo()"
                            style="font-size: 12px;">
                    </div>
                </div>
                <div id="fileInfo" class="text-muted" style="margin-top: 4px;"></div>
            </div>

            <div class="flex-between" style="margin-top: 8px;">
                <div class="flex-center" style="gap: 10px;">
                    <button id="startBtn" onclick="startDialog()" class="primary">‚ñ∂ Start Dialog</button>
                    <div class="flex-center" style="gap: 4px;">
                        <label for="maxTurns" style="margin: 0; font-size: 12px;">Turns:</label>
                        <input type="number" id="maxTurns" value="3" min="1" max="50" autocomplete="off"
                            style="width: 60px; padding: 6px; font-size: 13px;">
                    </div>
                    <div class="flex-center" style="gap: 4px; padding: 4px 8px; background: #f9f9f9; border-radius: 4px; border: 1px solid #d0d0d0;">
                        <input type="checkbox" id="autoGeneratePdf" checked style="cursor: pointer;">
                        <label for="autoGeneratePdf" style="margin: 0; font-size: 12px; cursor: pointer;" title="Automatically generate PDF when dialog completes">üìÑ Auto PDF</label>
                    </div>
                    <button onclick="showSaveToLibraryDialog()" class="secondary"
                        title="Save current prompt configuration to debate library">üíæ Save</button>
                    <button onclick="showDefaultPromptsEditor()" class="secondary"
                        title="Edit default prompt templates">üìù Defaults</button>
                </div>
                <div class="flex-center" style="gap: 8px;">
                    <button onclick="resetCache()" class="utility"
                        title="Clear conversation history from all AI clients">üîÑ Reset</button>
                    <button onclick="clearAll()" class="utility" style="background: #c55a11;">‚úñ Clear</button>
                </div>
            </div>
            <div id="status" class="status"></div>
        </div>

        <div id="debateQueueProgress"
            style="display: none; margin-bottom: 20px; padding: 16px; background: #e7f3ff; border: 2px solid #4472c4; border-radius: 8px;">
            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 12px;">
                <div style="font-weight: 600; font-size: 16px; color: #1f4e78;">
                    üéØ Running Debate Queue
                </div>
                <button onclick="cancelDebateQueue()" style="background: #c55a11; padding: 6px 16px; font-size: 13px;">
                    Cancel Queue
                </button>
            </div>
            <div
                style="display: grid; grid-template-columns: repeat(auto-fit, minmax(150px, 1fr)); gap: 12px; margin-bottom: 12px;">
                <div style="text-align: center; padding: 8px; background: #ffffff; border-radius: 4px;">
                    <div style="font-size: 24px; font-weight: 600; color: #4472c4;" id="queueCompleted">0</div>
                    <div style="font-size: 12px; color: #808080;">Completed</div>
                </div>
                <div style="text-align: center; padding: 8px; background: #ffffff; border-radius: 4px;">
                    <div style="font-size: 24px; font-weight: 600; color: #70ad47;" id="queueCurrent">-</div>
                    <div style="font-size: 12px; color: #808080;">Current</div>
                </div>
                <div style="text-align: center; padding: 8px; background: #ffffff; border-radius: 4px;">
                    <div style="font-size: 24px; font-weight: 600; color: #808080;" id="queueRemaining">0</div>
                    <div style="font-size: 12px; color: #808080;">Remaining</div>
                </div>
                <div style="text-align: center; padding: 8px; background: #ffffff; border-radius: 4px;">
                    <div style="font-size: 24px; font-weight: 600; color: #1f4e78;" id="queueTotal">0</div>
                    <div style="font-size: 12px; color: #808080;">Total</div>
                </div>
            </div>
            <div style="background: #d0d0d0; height: 8px; border-radius: 4px; overflow: hidden;">
                <div id="queueProgressBar"
                    style="background: linear-gradient(90deg, #4472c4, #70ad47); height: 100%; width: 0%; transition: width 0.3s ease;">
                </div>
            </div>
            <div id="queueCurrentDebate"
                style="margin-top: 8px; font-size: 13px; color: #1f4e78; font-style: italic; text-align: center;">
                Preparing debates...
            </div>
            <div id="queueTurnProgress"
                style="margin-top: 8px; padding: 8px; background: #ffffff; border-radius: 4px; border: 1px solid #d0d0d0; display: none;">
                <div style="font-size: 11px; color: #808080; margin-bottom: 4px; text-align: center;">Current Debate
                    Turn Progress</div>
                <div style="display: flex; justify-content: center; gap: 16px; font-size: 13px;">
                    <span><strong>Total:</strong> <span id="turnTotal">0</span></span>
                    <span style="color: #70ad47;"><strong>Done:</strong> <span id="turnDone">0</span></span>
                    <span style="color: #808080;"><strong>Left:</strong> <span id="turnLeft">0</span></span>
                </div>
            </div>
        </div>

        <div id="dialog" class="dialog-container" style="display: none;">
            <div class="loading">
                <div class="spinner"></div>
                <div>Starting dialog...</div>
            </div>
        </div>

        <div id="pdfExportSection" style="display: none; margin-top: 20px; text-align: center;">
            <div id="pdfDownloadLink" style="display: none; margin-bottom: 10px;">
                <a id="pdfDownloadAnchor" href="#" download
                    style="background: #70ad47; color: #ffffff; text-decoration: none; padding: 12px 24px; border-radius: 4px; font-size: 15px; font-weight: 500; box-shadow: 0 2px 4px rgba(112, 173, 71, 0.2); display: inline-block; transition: all 0.2s;"
                    onmouseover="this.style.background='#548235'; this.style.boxShadow='0 3px 6px rgba(112, 173, 71, 0.3)'; this.style.transform='translateY(-1px)'"
                    onmouseout="this.style.background='#70ad47'; this.style.boxShadow='0 2px 4px rgba(112, 173, 71, 0.2)'; this.style.transform='none'">
                    üìÑ Download PDF
                </a>
            </div>
            <button id="pdfExportBtn" onclick="exportToPdf()"
                style="background: #70ad47; color: #ffffff; border: none; padding: 12px 24px; border-radius: 4px; cursor: pointer; font-size: 15px; font-weight: 500; box-shadow: 0 2px 4px rgba(112, 173, 71, 0.2); transition: all 0.2s;"
                onmouseover="this.style.background='#548235'; this.style.boxShadow='0 3px 6px rgba(112, 173, 71, 0.3)'; this.style.transform='translateY(-1px)'"
                onmouseout="this.style.background='#70ad47'; this.style.boxShadow='0 2px 4px rgba(112, 173, 71, 0.2)'; this.style.transform='none'">
                üìÑ Export to PDF
            </button>
        </div>

        <!-- Summary Generation Progress -->
        <div id="summaryProgressSection"
            style="display: none; margin-top: 20px; padding: 16px; background: #e7f3ff; border: 2px solid #4472c4; border-radius: 8px; text-align: center;">
            <div style="font-size: 16px; font-weight: 600; color: #1f4e78; margin-bottom: 8px;">
                üìù Saving Participant Transcripts...
            </div>
            <div style="font-size: 13px; color: #4472c4;">
                Creating consolidated text files for each participant
            </div>
            <div class="spinner" style="margin: 12px auto;"></div>
        </div>

        <div id="gpuMonitoringSection"
            style="display: none; margin-top: 20px; padding: 20px; background: #f8f8f8; border: 1px solid #d0d0d0; border-radius: 8px;">
            <h3 style="margin-top: 0; color: #1f4e78; font-size: 18px;">GPU Power Consumption History</h3>
            <canvas id="gpuChart" width="800" height="300"
                style="background: white; border: 1px solid #d0d0d0; border-radius: 4px;"></canvas>
            <div id="gpuLegend"
                style="margin-top: 12px; display: flex; gap: 20px; justify-content: center; font-size: 13px;"></div>
            <div id="gpuStats" style="margin-top: 12px; font-size: 13px; color: #666; text-align: center;"></div>
        </div>
    </div>

    <div id="statusBar" class="status-bar idle" style="display: none;">
        <div class="status-bar-indicator"></div>
        <div class="status-bar-content">
            <span id="statusBarText">Ready</span>
            <span class="status-bar-turn" id="statusBarTurn"></span>
            <span id="ttsIndicator" style="margin-left: 12px; font-size: 12px; opacity: 0; transition: opacity 0.3s;">
                üéôÔ∏è <span id="ttsStatus">TTS</span> <span id="ttsCount"
                    style="background: rgba(255,255,255,0.2); padding: 2px 6px; border-radius: 3px; margin-left: 4px;">0</span>
            </span>
        </div>
        <div id="progressBarContainer"
            style="position: absolute; bottom: 0; left: 0; right: 0; height: 4px; background: rgba(0,0,0,0.2); overflow: hidden; display: none;">
            <div id="progressBar"
                style="height: 100%; width: 0%; background: rgba(255,255,255,0.8); transition: width 0.3s ease;"></div>
        </div>
    </div>

    <script>
        const socket = io();
        let dialogActive = false;
        let currentDialogId = null;
        let dialogData = [];

        // Debate library and queue management
        let debateLibrary = [];
        let debateQueue = [];
        let currentDebateIndex = 0;
        let isQueueRunning = false;
        let queueCancelled = false;
        let waitingForNextDebate = false; // Prevent double-execution of next debate

        // Turn tracking for current debate
        let currentDebateTotalTurns = 0;
        let currentDebateTurnsDone = 0;
        let currentMaxTurns = 0; // Max turns for current dialog

        // Auto-play audio management

        // TTS tracking
        let ttsCount = 0;
        let ttsGenerating = false;

        // GPU monitoring
        let gpuMonitoringData = [];
        let gpuChart = null;
        let gpuChartContext = null;

        // Dark mode functionality
        function toggleDarkMode() {
            const body = document.body;
            const isDark = body.classList.toggle('dark-mode');
            const toggleBtn = document.getElementById('darkModeToggle');
            localStorage.setItem('darkMode', isDark ? 'enabled' : 'disabled');
            if (toggleBtn) {
                toggleBtn.textContent = isDark ? '‚òÄÔ∏è' : 'üåô';
                toggleBtn.title = isDark ? 'Switch to Light Mode' : 'Switch to Dark Mode';
            }

            // Refresh energy estimate display if it exists
            const energySection = document.getElementById('energyEstimateSection');
            if (energySection && energySection.style.display !== 'none' && gpuMonitoringData.length > 0) {
                calculateAndDisplayEnergyEstimate();
            }
        }

        function loadDarkModePreference() {
            const darkModeEnabled = localStorage.getItem('darkMode') === 'enabled';
            const toggleBtn = document.getElementById('darkModeToggle');
            if (darkModeEnabled) {
                document.body.classList.add('dark-mode');
                if (toggleBtn) {
                    toggleBtn.textContent = '‚òÄÔ∏è';
                    toggleBtn.title = 'Switch to Light Mode';
                }
            }
        }

        loadDarkModePreference();

        // Audio generation toggle functionality
        function toggleAudioGeneration() {
            const audioEnabled = localStorage.getItem('audioGeneration') !== 'disabled';
            const newState = !audioEnabled;
            localStorage.setItem('audioGeneration', newState ? 'enabled' : 'disabled');
            updateAudioToggleButton();
        }

        function updateAudioToggleButton() {
            const audioEnabled = localStorage.getItem('audioGeneration') !== 'disabled';
            const toggleBtn = document.getElementById('audioToggle');
            if (toggleBtn) {
                if (audioEnabled) {
                    toggleBtn.textContent = 'üîä';
                    toggleBtn.title = 'Audio Generation: ON (click to disable)';
                    toggleBtn.style.background = '#70ad47';
                } else {
                    toggleBtn.textContent = 'üîá';
                    toggleBtn.title = 'Audio Generation: OFF (click to enable)';
                    toggleBtn.style.background = '#808080';
                }
            }
        }

        function isAudioGenerationEnabled() {
            return localStorage.getItem('audioGeneration') !== 'disabled';
        }

        // Load audio preference on page load
        updateAudioToggleButton();

        // Initialize shared model sync on page load
        updateSharedModel();

        // Global variable to store default prompts loaded from server
        let DEFAULT_PROMPTS = {
            intermediator_pre_prompt: `You are the intermediator for a dialog between two AI participants.
Your role is to present the participants with the rules and the topic.
You review each response before passing
it on to the other participant.
If you have to remind the participants of the rules you will.
If a participant misbehaves you will mention that in your final summary.
encourage brevity and clarity.`,
            participant_pre_prompt: `You are the participant in a debate.
You follow the instructions of the intermediator, review the responses of your adversary, and develop thoughtful on-point responses.`,
            participant_post_prompt: `You bottom line your response in 1 sentence.`
        };

        // Load default prompts from server
        async function loadDefaultPromptsFromServer() {
            try {
                const response = await fetch('/default_prompts');
                const data = await response.json();

                if (response.ok && data.prompts) {
                    DEFAULT_PROMPTS = data.prompts;
                    console.log('Default prompts loaded from server');
                } else {
                    console.warn('Failed to load default prompts from server, using fallback defaults');
                }
            } catch (error) {
                console.warn('Error loading default prompts from server:', error, '- using fallback defaults');
            }
        }

        // Load persisted prompt fields
        async function loadPersistedFields() {
            // First, load default prompts from server
            await loadDefaultPromptsFromServer();
            // Load prompt configuration (excluding pre/post prompts which always revert to defaults)
            const intermediatorPrePrompt = localStorage.getItem('idi_intermediator_pre_prompt');
            const intermediatorTopicPrompt = localStorage.getItem('idi_intermediator_topic_prompt');
            const participant1MidPrompt = localStorage.getItem('idi_participant1_mid_prompt');
            const participant2MidPrompt = localStorage.getItem('idi_participant2_mid_prompt');

            // Use localStorage value if exists, otherwise use default
            const intermediatorPrePromptEl = document.getElementById('intermediator-pre-prompt');
            if (intermediatorPrePrompt) {
                intermediatorPrePromptEl.value = intermediatorPrePrompt;
            } else {
                intermediatorPrePromptEl.value = DEFAULT_PROMPTS.intermediator_pre_prompt;
            }

            if (intermediatorTopicPrompt) document.getElementById('intermediator-topic-prompt').value = intermediatorTopicPrompt;

            // Participant pre-prompt: use localStorage if exists, otherwise use default
            const participantPrePromptEl = document.getElementById('participant-pre-prompt');
            const participantPrePrompt = localStorage.getItem('idi_participant_pre_prompt');
            if (participantPrePrompt) {
                participantPrePromptEl.value = participantPrePrompt;
            } else {
                participantPrePromptEl.value = DEFAULT_PROMPTS.participant_pre_prompt;
            }

            // Participant post-prompt: use localStorage if exists, otherwise use default
            const participantPostPromptEl = document.getElementById('participant-post-prompt');
            const participantPostPrompt = localStorage.getItem('idi_participant_post_prompt');
            if (participantPostPrompt) {
                participantPostPromptEl.value = participantPostPrompt;
            } else {
                participantPostPromptEl.value = DEFAULT_PROMPTS.participant_post_prompt;
            }
            if (participant1MidPrompt) document.getElementById('participant1-mid-prompt').value = participant1MidPrompt;
            if (participant2MidPrompt) document.getElementById('participant2-mid-prompt').value = participant2MidPrompt;

            // Load other settings (maxTurns always defaults to 3, so don't load it)
            const sharedSparkModel = localStorage.getItem('idi_shared_spark_model');
            const participant1Override = localStorage.getItem('idi_participant1_override') === 'true';
            const participant2Override = localStorage.getItem('idi_participant2_override') === 'true';
            const participant1Model = localStorage.getItem('idi_participant1_model');
            const participant2Model = localStorage.getItem('idi_participant2_model');

            // Always set maxTurns to default of 3
            document.getElementById('maxTurns').value = '3';

            if (sharedSparkModel) {
                document.getElementById('shared-spark-model').value = sharedSparkModel;
                updateSharedModel();
            }
            if (participant1Override !== null) {
                document.getElementById('participant1-override-model').checked = participant1Override;
                toggleParticipant1Model();
                if (participant1Model && participant1Override) {
                    document.getElementById('participant1-model').value = participant1Model;
                }
            }
            if (participant2Override !== null) {
                document.getElementById('participant2-override-model').checked = participant2Override;
                toggleParticipant2Model();
                if (participant2Model && participant2Override) {
                    document.getElementById('participant2-model').value = participant2Model;
                }
            }
        }

        // Save prompt fields to localStorage
        function savePromptFields() {
            localStorage.setItem('idi_intermediator_pre_prompt', document.getElementById('intermediator-pre-prompt').value);
            localStorage.setItem('idi_intermediator_topic_prompt', document.getElementById('intermediator-topic-prompt').value);
            localStorage.setItem('idi_participant_pre_prompt', document.getElementById('participant-pre-prompt').value);
            localStorage.setItem('idi_participant_post_prompt', document.getElementById('participant-post-prompt').value);
            localStorage.setItem('idi_participant1_mid_prompt', document.getElementById('participant1-mid-prompt').value);
            localStorage.setItem('idi_participant2_mid_prompt', document.getElementById('participant2-mid-prompt').value);

            // Save other settings (maxTurns always defaults to 3, so don't save it)
            localStorage.setItem('idi_shared_spark_model', document.getElementById('shared-spark-model').value);
            localStorage.setItem('idi_participant1_override', document.getElementById('participant1-override-model').checked);
            localStorage.setItem('idi_participant2_override', document.getElementById('participant2-override-model').checked);
            if (document.getElementById('participant1-override-model').checked) {
                localStorage.setItem('idi_participant1_model', document.getElementById('participant1-model').value);
            }
            if (document.getElementById('participant2-override-model').checked) {
                localStorage.setItem('idi_participant2_model', document.getElementById('participant2-model').value);
            }
        }

        // Ensure maxTurns is always set to 3 on page load (override any cached values)
        function ensureMaxTurnsDefault() {
            const maxTurnsInput = document.getElementById('maxTurns');
            if (maxTurnsInput) {
                maxTurnsInput.value = '3';
            }
        }

        // Initialize on page load - properly await async loading
        async function initializePage() {
            await loadPersistedFields();  // Wait for defaults to load from server
            ensureMaxTurnsDefault();
            loadDebateCount();
            loadDebateLibrary();
            checkAllServers();
        }

        // Set it immediately if DOM is already loaded, otherwise wait for DOMContentLoaded
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', () => {
                initializePage();
            });
        } else {
            initializePage();
        }

        // Auto-save prompt fields when they change
        document.addEventListener('input', function (e) {
            if (e.target.id && (
                (e.target.id.includes('prompt') &&
                    e.target.id !== 'participant-pre-prompt' &&
                    e.target.id !== 'participant-post-prompt') ||
                e.target.id === 'shared-spark-model' ||
                e.target.id === 'participant1-model' ||
                e.target.id === 'participant2-model'
            )) {
                savePromptFields();
            }
        });

        // Auto-save when checkboxes change
        document.addEventListener('change', function (e) {
            if (e.target.id && (
                e.target.id.includes('override') ||
                e.target.id === 'shared-spark-model'
            )) {
                savePromptFields();
            }
        });

        // Load models for a server
        async function loadModels(serverType) {
            const hostInput = document.getElementById(`${serverType}-host`);
            const modelSelect = document.getElementById(`${serverType}-model`);

            if (!hostInput || !modelSelect) return;

            const host = hostInput.value.trim();
            if (!host) return;

            try {
                const response = await fetch('/check_servers', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        servers: [{
                            host: host,
                            model: '',
                            name: serverType
                        }]
                    })
                });

                const result = await response.json();

                if (result.servers && result.servers.length > 0) {
                    const serverStatus = result.servers[0];
                    if (serverStatus.available_models && serverStatus.available_models.length > 0) {
                        const currentModel = modelSelect.value;
                        modelSelect.innerHTML = '';
                        serverStatus.available_models.forEach(model => {
                            const option = document.createElement('option');
                            option.value = model;
                            option.textContent = model;
                            if (model === currentModel || (model === serverStatus.model && !currentModel)) {
                                option.selected = true;
                            }
                            modelSelect.appendChild(option);
                        });
                    }
                }
            } catch (error) {
                console.error(`Error loading models for ${serverType}:`, error);
            }
        }

        // Check server status on page load
        function checkAllServers() {
            checkServerStatus('intermediator');
            checkServerStatus('participant1');
            checkServerStatus('participant2');
            // Also load models
            loadModels('intermediator');
            loadModels('participant1');
            loadModels('participant2');
        }

        async function checkServerStatus(serverType) {
            const hostInput = document.getElementById(`${serverType}-host`);
            const modelSelect = document.getElementById(`${serverType}-model`);
            const statusIndicator = document.getElementById(`${serverType}-status-indicator`);
            const statusText = document.getElementById(`${serverType}-status-text`);

            if (!hostInput || !modelSelect || !statusIndicator || !statusText) return;

            const host = hostInput.value.trim();

            if (!host) {
                statusIndicator.className = 'status-indicator offline';
                statusText.className = 'status-text offline';
                statusText.textContent = 'Not configured';
                return;
            }

            // Show checking state
            statusIndicator.className = 'status-indicator checking';
            statusText.className = 'status-text checking';
            statusText.textContent = 'Checking...';

            try {
                const response = await fetch('/check_servers', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        servers: [{
                            host: host,
                            model: modelSelect.value || '',
                            name: serverType
                        }]
                    })
                });

                const result = await response.json();

                if (result.servers && result.servers.length > 0) {
                    const serverStatus = result.servers[0];

                    // Update model dropdown with available models
                    if (serverStatus.available_models && serverStatus.available_models.length > 0) {
                        const currentModel = modelSelect.value;
                        const isDisabled = modelSelect.disabled;
                        modelSelect.innerHTML = '';
                        serverStatus.available_models.forEach(model => {
                            const option = document.createElement('option');
                            option.value = model;
                            option.textContent = model;
                            if (model === currentModel || (model === serverStatus.model && !currentModel)) {
                                option.selected = true;
                            }
                            modelSelect.appendChild(option);
                        });
                        modelSelect.disabled = isDisabled;

                        // If this is a participant and shared model is enabled, update shared model dropdown too
                        if ((serverType === 'participant1' || serverType === 'participant2') && serverStatus.available_models.length > 0) {
                            const sharedModelSelect = document.getElementById('shared-spark-model');
                            if (sharedModelSelect) {
                                const currentShared = sharedModelSelect.value;
                                const hasCurrent = Array.from(sharedModelSelect.options).some(opt => opt.value === currentShared);
                                if (!hasCurrent || sharedModelSelect.options.length <= 1) {
                                    // Update shared model dropdown with available models
                                    sharedModelSelect.innerHTML = '';
                                    serverStatus.available_models.forEach(model => {
                                        const option = document.createElement('option');
                                        option.value = model;
                                        option.textContent = model;
                                        if (model === currentShared || (model === 'gpt-oss:20b' && !currentShared)) {
                                            option.selected = true;
                                        }
                                        sharedModelSelect.appendChild(option);
                                    });
                                }
                            }
                        }
                    }

                    if (serverStatus.available) {
                        statusIndicator.className = 'status-indicator online';
                        statusText.className = 'status-text online';
                        statusText.textContent = 'Online';
                    } else {
                        statusIndicator.className = 'status-indicator offline';
                        statusText.className = 'status-text offline';
                        statusText.textContent = 'Offline';
                    }
                } else {
                    statusIndicator.className = 'status-indicator offline';
                    statusText.className = 'status-text offline';
                    statusText.textContent = 'Error';
                }
            } catch (error) {
                statusIndicator.className = 'status-indicator offline';
                statusText.className = 'status-text offline';
                statusText.textContent = 'Error';
            }
        }

        socket.on('connect', () => {
            console.log('Connected to server');
            showStatus('Connected to server', 'success');
            // Check all servers on connect (with a small delay to ensure DOM is ready)
            setTimeout(() => {
                checkAllServers();
            }, 500);
            // Check servers every 30 seconds
            setInterval(checkAllServers, 30000);
        });

        // Also check on page load (in case socket connects before DOM is ready)
        window.addEventListener('load', () => {
            setTimeout(() => {
                checkAllServers();
            }, 1000);
        });

        socket.on('dialog_started', (data) => {
            dialogActive = true;
            document.getElementById('startBtn').disabled = true;
            currentDialogId = data.dialog_id;
            dialogData = [];

            // Clear auto-play queue for new dialog
            autoPlayQueue = [];
            if (autoPlayPlayer) {
                autoPlayPlayer.pause();
                autoPlayPlayer.src = '';
                autoPlayPlayer = null;
            }
            isAutoPlaying = false;

            // Hide PDF export button
            hidePdfButton();

            // Initialize GPU monitoring
            initGPUChart();

            // Show status bar
            const statusBar = document.getElementById('statusBar');
            statusBar.style.display = 'flex';
            updateStatusBar('intermediator', 'Starting dialog...', 0, currentMaxTurns);

            const dialogDiv = document.getElementById('dialog');
            dialogDiv.style.display = 'block';
            dialogDiv.innerHTML = `
                <div class="dialog-turn intermediator">
                    <div class="turn-header intermediator">Intermediator: ${data.intermediator}</div>
                    <div class="turn-content">Starting dialog...</div>
                </div>
            `;

            // Ensure dialog container is visible and scrolled to top
            dialogDiv.scrollTop = 0;

            showStatus('Dialog started', 'info');
        });

        socket.on('dialog_update', (data) => {
            handleDialogUpdate(data);
        });

        socket.on('tts_progress', (data) => {
            const indicator = document.getElementById('ttsIndicator');
            const status = document.getElementById('ttsStatus');
            const count = document.getElementById('ttsCount');

            if (data.status === 'generating') {
                ttsGenerating = true;
                indicator.style.opacity = '1';
                status.textContent = 'Generating...';
            } else if (data.status === 'complete') {
                ttsCount++;
                count.textContent = ttsCount;
                ttsGenerating = false;
                status.textContent = 'Ready';
                // Keep indicator visible for a moment
                setTimeout(() => {
                    if (!ttsGenerating) {
                        indicator.style.opacity = '0.7';
                    }
                }, 500);
            } else if (data.status === 'error') {
                ttsGenerating = false;
                status.textContent = 'Error';
                indicator.style.opacity = '0.7';
                console.error('TTS Error:', data.error);
            }
        });

        socket.on('error', (data) => {
            showStatus(`Error: ${data.error}`, 'error');
        });

        socket.on('dialog_saved', (data) => {
            const filename = data.txt_path ? data.txt_path.split('/').pop() : 'dialog files';
            showStatus(`Dialog saved: ${filename}`, 'success');
        });

        socket.on('pdf_ready', (data) => {
            // PDF data is ready
            if (data.dialog_id === currentDialogId) {
                showPdfButton();

                // Auto-generate PDF if toggle is enabled
                const autoGenerateCheckbox = document.getElementById('autoGeneratePdf');
                const shouldAutoGenerate = autoGenerateCheckbox && autoGenerateCheckbox.checked;
                
                if (shouldAutoGenerate) {
                    // Small delay to ensure UI updates, then auto-export
                    setTimeout(() => {
                        exportToPdf();
                    }, 500);
                }
            }
        });

        socket.on('pdf_generated', (data) => {
            // PDF has been generated automatically
            if (data.dialog_id === currentDialogId) {
                showPdfButton();

                // Show download link
                const downloadLink = document.getElementById('pdfDownloadLink');
                const downloadAnchor = document.getElementById('pdfDownloadAnchor');
                if (downloadLink && downloadAnchor && data.filename) {
                    downloadAnchor.href = `/download_pdf/${data.filename}`;
                    downloadAnchor.download = data.filename;
                    downloadLink.style.display = 'block';

                    // Hide the export button since PDF is already generated
                    const exportBtn = document.getElementById('pdfExportBtn');
                    if (exportBtn) {
                        exportBtn.style.display = 'none';
                    }

                    showStatus(`PDF generated: ${data.filename}`, 'success');
                }
            }
        });

        // GPU monitoring
        socket.on('gpu_status_update', (data) => {
            if (data.dialog_id === currentDialogId) {
                gpuMonitoringData.push(data.sample);
                updateGPUChart();
            }
        });

        function initGPUChart() {
            const canvas = document.getElementById('gpuChart');
            if (!canvas) return;

            gpuChartContext = canvas.getContext('2d');
            gpuMonitoringData = [];

            // Show GPU monitoring section
            document.getElementById('gpuMonitoringSection').style.display = 'block';

            // Hide energy estimate section until dialog completes
            const energySection = document.getElementById('energyEstimateSection');
            if (energySection) {
                energySection.style.display = 'none';
            }
        }

        function updateGPUChart() {
            if (!gpuChartContext || gpuMonitoringData.length === 0) return;

            const canvas = document.getElementById('gpuChart');
            const ctx = gpuChartContext;
            const width = canvas.width;
            const height = canvas.height;

            // Clear canvas
            ctx.clearRect(0, 0, width, height);

            // Chart dimensions
            const padding = 40;
            const chartWidth = width - 2 * padding;
            const chartHeight = height - 2 * padding;

            // Find max wattage for scaling
            let maxWattage = 0;
            gpuMonitoringData.forEach(sample => {
                Object.values(sample.servers || {}).forEach(server => {
                    (server.gpus || []).forEach(gpu => {
                        maxWattage = Math.max(maxWattage, gpu.power_draw_watts || 0);
                    });
                });
            });
            maxWattage = Math.ceil(maxWattage / 50) * 50; // Round up to nearest 50W

            // Draw axes
            ctx.strokeStyle = '#333';
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.moveTo(padding, padding);
            ctx.lineTo(padding, height - padding);
            ctx.lineTo(width - padding, height - padding);
            ctx.stroke();

            // Y-axis labels (wattage)
            ctx.fillStyle = '#333';
            ctx.font = '11px sans-serif';
            ctx.textAlign = 'right';
            for (let i = 0; i <= 5; i++) {
                const watts = (maxWattage / 5) * i;
                const y = height - padding - (chartHeight / 5) * i;
                ctx.fillText(watts.toFixed(0) + 'W', padding - 5, y + 3);

                // Grid lines
                ctx.strokeStyle = '#e0e0e0';
                ctx.beginPath();
                ctx.moveTo(padding, y);
                ctx.lineTo(width - padding, y);
                ctx.stroke();
            }

            // X-axis label
            ctx.fillStyle = '#333';
            ctx.textAlign = 'center';
            ctx.fillText('Time (seconds)', width / 2, height - 10);

            // Plot data
            const colors = {
                'intermediator': '#4472c4',
                'participant1': '#70ad47',
                'participant2': '#ed7d31'
            };

            const serverStats = {
                'intermediator': { maxWatts: 0, avgWatts: 0, samples: 0 },
                'participant1': { maxWatts: 0, avgWatts: 0, samples: 0 },
                'participant2': { maxWatts: 0, avgWatts: 0, samples: 0 }
            };

            Object.keys(colors).forEach(serverRole => {
                ctx.strokeStyle = colors[serverRole];
                ctx.lineWidth = 2;
                ctx.beginPath();

                let started = false;
                gpuMonitoringData.forEach((sample, index) => {
                    const server = sample.servers[serverRole];
                    if (server && server.gpus && server.gpus.length > 0) {
                        const watts = server.gpus[0].power_draw_watts || 0;
                        const x = padding + (index / Math.max(1, gpuMonitoringData.length - 1)) * chartWidth;
                        const y = height - padding - (watts / maxWattage) * chartHeight;

                        if (!started) {
                            ctx.moveTo(x, y);
                            started = true;
                        } else {
                            ctx.lineTo(x, y);
                        }

                        // Update stats
                        serverStats[serverRole].maxWatts = Math.max(serverStats[serverRole].maxWatts, watts);
                        serverStats[serverRole].avgWatts += watts;
                        serverStats[serverRole].samples++;
                    }
                });

                ctx.stroke();
            });

            // Update legend
            const legendDiv = document.getElementById('gpuLegend');
            legendDiv.innerHTML = Object.keys(colors).map(role => {
                const stats = serverStats[role];
                const avg = stats.samples > 0 ? (stats.avgWatts / stats.samples).toFixed(1) : '0.0';
                return `<div style="display: flex; align-items: center; gap: 6px;">
                    <div style="width: 20px; height: 3px; background: ${colors[role]};"></div>
                    <span>${role.charAt(0).toUpperCase() + role.slice(1)}: ${avg}W avg, ${stats.maxWatts.toFixed(1)}W peak</span>
                </div>`;
            }).join('');

            // Update stats
            const duration = gpuMonitoringData.length > 0 ? gpuMonitoringData[gpuMonitoringData.length - 1].elapsed.toFixed(1) : '0';
            document.getElementById('gpuStats').textContent = `Duration: ${duration}s | Samples: ${gpuMonitoringData.length}`;
        }

        function calculateAndDisplayEnergyEstimate() {
            if (gpuMonitoringData.length === 0) return;

            // Calculate energy consumption for each server
            const serverEnergy = {
                'intermediator': { totalWattSeconds: 0, samples: 0, name: 'Intermediator' },
                'participant1': { totalWattSeconds: 0, samples: 0, name: 'Participant 1' },
                'participant2': { totalWattSeconds: 0, samples: 0, name: 'Participant 2' }
            };

            // Calculate time interval between samples
            let prevTime = 0;
            gpuMonitoringData.forEach((sample, index) => {
                const currentTime = sample.elapsed || 0;
                const deltaTime = index === 0 ? 0 : currentTime - prevTime;

                Object.keys(serverEnergy).forEach(serverRole => {
                    const server = sample.servers[serverRole];
                    if (server && server.gpus && server.gpus.length > 0) {
                        const watts = server.gpus[0].power_draw_watts || 0;
                        // Energy = Power √ó Time (in watt-seconds)
                        serverEnergy[serverRole].totalWattSeconds += watts * deltaTime;
                        serverEnergy[serverRole].samples++;
                    }
                });

                prevTime = currentTime;
            });

            // Convert to watt-hours and create display
            const colors = {
                'intermediator': '#4472c4',
                'participant1': '#70ad47',
                'participant2': '#ed7d31'
            };

            // Check for dark mode
            const isDarkMode = document.body.classList.contains('dark-mode');
            const bgColor = isDarkMode ? '#2d2d2d' : 'white';
            const borderColor = isDarkMode ? '#404040' : '#1f4e78';
            const titleColor = isDarkMode ? '#6ba3d8' : '#1f4e78';
            const cardBg = isDarkMode ? '#1a1a1a' : '#f8f8f8';
            const textColor = isDarkMode ? '#e0e0e0' : '#333';
            const subtextColor = isDarkMode ? '#a0a0a0' : '#666';
            const totalBg = isDarkMode ? '#1a3a4a' : '#e8f4f8';

            let totalEnergy = 0;
            let serverStats = [];

            Object.keys(serverEnergy).forEach(serverRole => {
                const data = serverEnergy[serverRole];
                const energyWh = data.totalWattSeconds / 3600; // Convert to watt-hours
                totalEnergy += energyWh;

                const serverIcon = serverRole === 'intermediator' ? 'üî∑' : serverRole === 'participant1' ? 'üü¢' : 'üü†';
                const shortName = serverRole === 'intermediator' ? 'Int' : serverRole === 'participant1' ? 'P1' : 'P2';
                serverStats.push(`<span style="color: ${colors[serverRole]}; font-weight: 600;">${serverIcon} ${shortName}: ${energyWh.toFixed(2)} Wh</span>`);
            });

            let energyHTML = `<div style="margin-top: 15px; padding: 10px; background: ${bgColor}; border: 1px solid ${borderColor}; border-radius: 6px;">
                <div style="display: flex; align-items: center; gap: 15px; flex-wrap: wrap; font-size: 13px;">
                    <span style="font-weight: 600; color: ${titleColor};">‚ö° Energy:</span>
                    ${serverStats.join(' | ')}
                    <span style="font-weight: 700; color: ${titleColor}; margin-left: auto; padding: 4px 12px; background: ${totalBg}; border-radius: 4px;">Total: ${totalEnergy.toFixed(2)} Wh</span>
                </div>
            </div>`;

            // Insert energy estimate after GPU monitoring section
            const gpuSection = document.getElementById('gpuMonitoringSection');
            let energySection = document.getElementById('energyEstimateSection');

            if (!energySection) {
                energySection = document.createElement('div');
                energySection.id = 'energyEstimateSection';
                gpuSection.parentNode.insertBefore(energySection, gpuSection.nextSibling);
            }

            energySection.innerHTML = energyHTML;
            energySection.style.display = 'block';
        }

        function handleDialogUpdate(data) {
            const dialogDiv = document.getElementById('dialog');
            const { type, speaker, message, content, answer, tokens, role } = data;

            switch (type) {
                case 'dialog_started':
                    // Already handled
                    break;

                case 'intermediator_turn':
                case 'participant_turn':
                    // Add new turn
                    const turnDiv = document.createElement('div');
                    turnDiv.className = `dialog-turn ${speaker || role}`;
                    turnDiv.id = `turn-${dialogData.length}`;

                    const speakerName = speaker === 'intermediator' ? 'Intermediator' :
                        speaker === 'participant1' ? 'Participant 1' : 'Participant 2';

                    // Get server name for status display
                    let serverName = speakerName;
                    if (speaker === 'intermediator') {
                        serverName = data.intermediator || 'Intermediator';
                    } else if (speaker === 'participant1') {
                        serverName = data.participant1 || 'Participant 1';
                    } else if (speaker === 'participant2') {
                        serverName = data.participant2 || 'Participant 2';
                    }

                    // Check if this is a summary (will be marked in the data)
                    const isSummary = data.is_summary || false;
                    const turnLabel = isSummary ? `${speakerName} - Summary` : speakerName;

                    if (isSummary) {
                        turnDiv.classList.add('summary');
                    }

                    // Update status bar - show "thinking" if thinking flag is set
                    const turnNum = data.turn !== undefined ? data.turn : dialogData.length;
                    const isThinking = data.thinking || false;
                    let statusText;
                    if (isThinking) {
                        statusText = isSummary ? `${serverName} is generating summary...` : `${serverName} is thinking...`;
                    } else {
                        statusText = isSummary ? 'Summarizing dialog...' : `${speakerName} is speaking...`;
                    }
                    updateStatusBar(speaker || role, statusText, turnNum, currentMaxTurns);

                    turnDiv.innerHTML = `
                        <div class="turn-header ${speaker || role}">${turnLabel}</div>
                        <div class="turn-content streaming" id="content-${dialogData.length}"></div>
                    `;

                    dialogDiv.appendChild(turnDiv);
                    dialogData.push({ speaker: speaker || role, content: '', is_summary: isSummary });

                    // Auto-scroll to show the new turn
                    turnDiv.scrollIntoView({ behavior: 'smooth', block: 'end' });
                    break;

                case 'content':
                    // Append streaming content
                    const lastTurn = dialogData[dialogData.length - 1];
                    if (lastTurn) {
                        lastTurn.content += content;
                        const contentEl = document.getElementById(`content-${dialogData.length - 1}`);
                        if (contentEl) {
                            contentEl.textContent = lastTurn.content;
                            contentEl.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
                        }
                        // Update status bar to show who is currently speaking
                        const speakerName = lastTurn.speaker === 'intermediator' ? 'Intermediator' :
                            lastTurn.speaker === 'participant1' ? 'Participant 1' : 'Participant 2';
                        const statusText = lastTurn.is_summary ? 'Summarizing dialog...' : `${speakerName} is speaking...`;
                        updateStatusBar(lastTurn.speaker, statusText, null);
                    }
                    break;

                case 'response_complete':
                    // Complete the turn
                    const turnIndex = dialogData.length - 1;
                    const contentEl = document.getElementById(`content-${turnIndex}`);
                    if (contentEl && answer) {
                        contentEl.textContent = answer;
                        contentEl.classList.remove('streaming');

                        if (tokens) {
                            const tokensDiv = document.createElement('div');
                            tokensDiv.className = 'tokens';
                            tokensDiv.textContent = `Tokens: ${tokens.total} (${tokens.prompt_tokens} prompt + ${tokens.completion_tokens} completion)`;
                            contentEl.parentElement.appendChild(tokensDiv);
                        }

                        // Update status bar - turn is complete, waiting for next speaker
                        const lastTurnData = dialogData[turnIndex];
                        if (lastTurnData) {
                            const speakerName = lastTurnData.speaker === 'intermediator' ? 'Intermediator' :
                                lastTurnData.speaker === 'participant1' ? 'Participant 1' : 'Participant 2';
                            updateStatusBar(lastTurnData.speaker, `${speakerName} finished speaking`, null);

                            // Update turn count if this is a participant response (not intermediator/moderation)
                            if (isQueueRunning && (lastTurnData.speaker === 'participant1' || lastTurnData.speaker === 'participant2')) {
                                currentDebateTurnsDone++;
                                updateTurnProgress();
                            }
                        }
                    }
                    break;

                case 'dialog_complete':
                    dialogActive = false;
                    document.getElementById('startBtn').disabled = false;

                    // Show summary generation progress
                    document.getElementById('summaryProgressSection').style.display = 'block';

                    // Set a timeout to hide the progress section if summaries don't complete in 30 seconds
                    setTimeout(() => {
                        const progressSection = document.getElementById('summaryProgressSection');
                        if (progressSection && progressSection.style.display !== 'none') {
                            progressSection.style.display = 'none';
                            updateStatusBar('idle', 'Dialog completed (transcripts saved)', null);

                            // If queue is running, continue to next debate even if summaries timed out
                            if (isQueueRunning && !queueCancelled && !waitingForNextDebate) {
                                waitingForNextDebate = true;
                                setTimeout(() => {
                                    runNextDebateInQueue();
                                }, 2000);
                            }
                        }
                    }, 30000);

                    // If queue is running, keep status bar visible and show transition
                    if (isQueueRunning && !queueCancelled) {
                        updateStatusBar('intermediator', 'Debate completed - Generating summaries...', null);

                        // Hide turn progress temporarily
                        updateTurnProgress();

                        currentDebateIndex++;
                        updateQueueProgress();
                    } else {
                        // Not in queue, show completion status
                        updateStatusBar('idle', 'Generating argument summaries...', null);

                        // Hide turn progress
                        updateTurnProgress();
                    }

                    showStatus('Dialog completed - generating summaries...', 'success');
                    // PDF button will be shown when pdf_ready event is received
                    break;

                case 'summaries_generated':
                    // Hide progress indicator
                    document.getElementById('summaryProgressSection').style.display = 'none';

                    // Calculate and display total energy consumption
                    calculateAndDisplayEnergyEstimate();

                    // Update status
                    updateStatusBar('idle', 'Transcripts saved successfully', null);

                    if (isQueueRunning && !queueCancelled && !waitingForNextDebate) {
                        waitingForNextDebate = true;
                        // Small delay before starting next debate
                        setTimeout(() => {
                            runNextDebateInQueue();
                        }, 2000);
                    } else {
                        updateStatusBar('idle', 'Dialog completed with summaries', null);
                    }
                    break;

                case 'summaries_error':
                    // Hide progress indicator
                    document.getElementById('summaryProgressSection').style.display = 'none';

                    // Show error
                    showStatus(`Error saving transcripts: ${data.error}`, 'error');
                    updateStatusBar('idle', 'Error saving transcripts', null);
                    break;
            }
        }

        async function startDialog() {
            try {
                // Check that intermediator topic prompt is provided
                const intermediatorTopicPrompt = document.getElementById('intermediator-topic-prompt').value.trim();
                if (!intermediatorTopicPrompt) {
                    showStatus('Please provide the Intermediator Topic/Instructions Prompt', 'error');
                    // Expand prompt config section if collapsed
                    const promptConfigSection = document.getElementById('promptConfigSection');
                    if (promptConfigSection && promptConfigSection.style.display === 'none') {
                        togglePromptConfig();
                    }
                    return;
                }

                // Reset TTS counter for new dialog
                ttsCount = 0;
                document.getElementById('ttsCount').textContent = '0';
                document.getElementById('ttsIndicator').style.opacity = '0';

                const fileInput = document.getElementById('fileUpload');
                let sessionId = null;

                if (fileInput.files && fileInput.files.length > 0) {
                    const file = fileInput.files[0];
                    showStatus('Uploading file...', 'info');

                    const formData = new FormData();
                    formData.append('file', file);

                    const response = await fetch('/upload', {
                        method: 'POST',
                        body: formData
                    });

                    const result = await response.json();
                    if (!response.ok) {
                        showStatus(`Upload error: ${result.error}`, 'error');
                        return;
                    }

                    sessionId = result.session_id;
                    showStatus(`File "${result.filename}" uploaded`, 'success');
                }

                const intermediator = {
                    host: document.getElementById('intermediator-host').value.trim(),
                    model: document.getElementById('intermediator-model').value.trim(),
                    name: document.getElementById('intermediator-name').value.trim()
                };

                const participant1 = {
                    host: document.getElementById('participant1-host').value.trim(),
                    model: document.getElementById('participant1-model').value.trim(),
                    name: document.getElementById('participant1-name').value.trim()
                };

                const participant2 = {
                    host: document.getElementById('participant2-host').value.trim(),
                    model: document.getElementById('participant2-model').value.trim(),
                    name: document.getElementById('participant2-name').value.trim()
                };

                const maxTurns = parseInt(document.getElementById('maxTurns').value) || 3;
                currentMaxTurns = maxTurns; // Store for progress tracking

                // Show status bar immediately to provide feedback
                const statusBar = document.getElementById('statusBar');
                statusBar.style.display = 'flex';
                updateStatusBar('intermediator', 'Preparing dialog...', 0, maxTurns);

                // Get shared model and override flags
                const sharedSparkModel = document.getElementById('shared-spark-model').value.trim();
                const participant1Override = document.getElementById('participant1-override-model').checked;
                const participant2Override = document.getElementById('participant2-override-model').checked;

                // Get prompt configuration
                const promptConfig = {
                    intermediator_pre_prompt: document.getElementById('intermediator-pre-prompt').value.trim() || null,
                    intermediator_topic_prompt: document.getElementById('intermediator-topic-prompt').value.trim() || null,
                    participant_pre_prompt: document.getElementById('participant-pre-prompt').value.trim() || null,
                    participant1_mid_prompt: document.getElementById('participant1-mid-prompt').value.trim() || null,
                    participant2_mid_prompt: document.getElementById('participant2-mid-prompt').value.trim() || null,
                    participant_post_prompt: document.getElementById('participant-post-prompt').value.trim() || null
                };

                // Remove null values
                Object.keys(promptConfig).forEach(key => {
                    if (promptConfig[key] === null || promptConfig[key] === '') {
                        delete promptConfig[key];
                    }
                });

                socket.emit('start_dialog', {
                    session_id: sessionId,
                    intermediator: intermediator,
                    participant1: participant1,
                    participant2: participant2,
                    max_turns: maxTurns,
                    thinking_params: {},
                    shared_spark_model: sharedSparkModel || null,
                    participant1_override_model: participant1Override ? participant1.model : null,
                    participant2_override_model: participant2Override ? participant2.model : null,
                    prompt_config: promptConfig,
                    enable_tts: isAudioGenerationEnabled()
                });
            } catch (error) {
                console.error('Error in startDialog:', error);
                showStatus(`Error: ${error.message}`, 'error');
            }
        }

        function updateFileInfo() {
            const fileInput = document.getElementById('fileUpload');
            const fileInfo = document.getElementById('fileInfo');
            if (fileInput.files && fileInput.files.length > 0) {
                const file = fileInput.files[0];
                const sizeKB = (file.size / 1024).toFixed(2);
                fileInfo.textContent = `Selected: ${file.name} (${sizeKB} KB)`;
                fileInfo.style.color = '#70ad47';
            } else {
                fileInfo.textContent = '';
            }
        }

        function showStatus(message, type) {
            const statusEl = document.getElementById('status');
            statusEl.textContent = message;
            statusEl.className = `status ${type}`;
            statusEl.style.display = 'block';

            if (type === 'success' || type === 'info') {
                setTimeout(() => {
                    statusEl.style.display = 'none';
                }, 3000);
            }
        }

        function toggleParticipant1Model() {
            const override = document.getElementById('participant1-override-model').checked;
            const modelInput = document.getElementById('participant1-model');
            modelInput.disabled = !override;
            if (!override) {
                updateSharedModel();
            } else {
                // If enabling override, check status with the new model
                checkServerStatus('participant1');
            }
            savePromptFields();
        }

        function toggleParticipant2Model() {
            const override = document.getElementById('participant2-override-model').checked;
            const modelInput = document.getElementById('participant2-model');
            modelInput.disabled = !override;
            if (!override) {
                updateSharedModel();
            } else {
                // If enabling override, check status with the new model
                checkServerStatus('participant2');
            }
            savePromptFields();
        }

        function updateSharedModel() {
            const sharedModel = document.getElementById('shared-spark-model').value;
            if (!document.getElementById('participant1-override-model').checked) {
                const participant1Model = document.getElementById('participant1-model');
                // Check if the shared model exists in the dropdown
                if (Array.from(participant1Model.options).some(opt => opt.value === sharedModel)) {
                    participant1Model.value = sharedModel;
                }
                checkServerStatus('participant1');
            }
            if (!document.getElementById('participant2-override-model').checked) {
                const participant2Model = document.getElementById('participant2-model');
                // Check if the shared model exists in the dropdown
                if (Array.from(participant2Model.options).some(opt => opt.value === sharedModel)) {
                    participant2Model.value = sharedModel;
                }
                checkServerStatus('participant2');
            }
            savePromptFields();
        }

        function togglePromptConfig() {
            const section = document.getElementById('promptConfigSection');
            const toggle = document.getElementById('promptConfigToggle');
            if (section.style.display === 'none') {
                section.style.display = 'block';
                toggle.textContent = '‚ñº';
            } else {
                section.style.display = 'none';
                toggle.textContent = '‚ñ∂';
            }
        }

        function resetCache() {
            if (confirm('Reset conversation cache for all AI clients? This will clear their conversation history.')) {
                socket.emit('reset_dialog_cache', { reset_all: true });
            }
        }

        socket.on('cache_reset', (data) => {
            showStatus(data.message, 'success');
        });

        let statusBarHideTimeout;

        function updateStatusBar(speaker, text, turnNum, maxTurns) {
            const statusBar = document.getElementById('statusBar');
            const statusBarText = document.getElementById('statusBarText');
            const statusBarTurn = document.getElementById('statusBarTurn');
            const progressBarContainer = document.getElementById('progressBarContainer');
            const progressBar = document.getElementById('progressBar');

            if (!statusBar || !statusBarText) return;

            // Show status bar
            statusBar.style.display = 'flex';

            // Clear any pending hide timeout
            if (statusBarHideTimeout) {
                clearTimeout(statusBarHideTimeout);
                statusBarHideTimeout = null;
            }

            // Update classes to change color based on speaker
            statusBar.className = 'status-bar ' + speaker;

            // Update text
            statusBarText.textContent = text;

            // Update turn number and progress
            if (statusBarTurn) {
                if (turnNum !== null && turnNum !== undefined && maxTurns) {
                    const totalTurns = maxTurns * 2; // Each participant speaks maxTurns times
                    const progress = Math.min(100, Math.round((turnNum / totalTurns) * 100));
                    statusBarTurn.textContent = `(Turn ${turnNum}/${totalTurns} - ${progress}%)`;

                    // Update progress bar
                    if (progressBarContainer && progressBar) {
                        progressBarContainer.style.display = 'block';
                        progressBar.style.width = progress + '%';
                    }
                } else {
                    statusBarTurn.textContent = '';
                    // Hide progress bar when no turn info
                    if (progressBarContainer) {
                        progressBarContainer.style.display = 'none';
                    }
                }
            }

            // Auto-hide after 3 seconds when idle
            if (speaker === 'idle') {
                statusBarHideTimeout = setTimeout(() => {
                    statusBar.style.display = 'none';
                }, 3000);
            }
        }

        function clearAll() {
            // Clear prompt fields (pre/post prompts always revert to defaults)
            document.getElementById('intermediator-pre-prompt').value = DEFAULT_PROMPTS.intermediator_pre_prompt;
            document.getElementById('intermediator-topic-prompt').value = '';
            document.getElementById('participant-pre-prompt').value = DEFAULT_PROMPTS.participant_pre_prompt;
            document.getElementById('participant1-mid-prompt').value = '';
            document.getElementById('participant2-mid-prompt').value = '';
            document.getElementById('participant-post-prompt').value = DEFAULT_PROMPTS.participant_post_prompt;

            // Clear other fields (maxTurns always defaults to 3)
            document.getElementById('fileUpload').value = '';
            document.getElementById('fileInfo').textContent = '';
            document.getElementById('maxTurns').value = '3';
            document.getElementById('shared-spark-model').value = 'gpt-oss:20b';
            document.getElementById('participant1-override-model').checked = false;
            document.getElementById('participant2-override-model').checked = false;
            toggleParticipant1Model();
            toggleParticipant2Model();
            updateSharedModel();

            document.getElementById('dialog').style.display = 'none';
            dialogData = [];
            dialogActive = false;
            currentDialogId = null;

            // Hide PDF export button
            hidePdfButton();

            // Hide status bar
            const statusBar = document.getElementById('statusBar');
            if (statusBar) {
                statusBar.style.display = 'none';
            }

            // Reset prompt config section
            const promptConfigSection = document.getElementById('promptConfigSection');
            const promptConfigToggle = document.getElementById('promptConfigToggle');
            if (promptConfigSection) {
                promptConfigSection.style.display = 'none';
            }
            if (promptConfigToggle) {
                promptConfigToggle.textContent = '‚ñ∂';
            }

            // Clear localStorage (excluding pre/post prompts and maxTurns which aren't persisted)
            localStorage.removeItem('idi_intermediator_pre_prompt');
            localStorage.removeItem('idi_intermediator_topic_prompt');
            localStorage.removeItem('idi_participant1_mid_prompt');
            localStorage.removeItem('idi_participant2_mid_prompt');
            localStorage.removeItem('idi_shared_spark_model');
            localStorage.removeItem('idi_participant1_override');
            localStorage.removeItem('idi_participant2_override');
            localStorage.removeItem('idi_participant1_model');
            localStorage.removeItem('idi_participant2_model');
            // Explicitly remove any old maxTurns value that might exist
            localStorage.removeItem('idi_max_turns');

            showStatus('All fields cleared', 'success');
        }

        function showPdfButton() {
            const pdfSection = document.getElementById('pdfExportSection');
            if (pdfSection && currentDialogId) {
                pdfSection.style.display = 'block';
            }
            
            // Show manual export button if auto-generate is disabled
            const autoGenerateCheckbox = document.getElementById('autoGeneratePdf');
            const pdfExportBtn = document.getElementById('pdfExportBtn');
            if (pdfExportBtn && autoGenerateCheckbox && !autoGenerateCheckbox.checked) {
                pdfExportBtn.style.display = 'inline-block';
            } else if (pdfExportBtn && autoGenerateCheckbox && autoGenerateCheckbox.checked) {
                // Hide manual button if auto-generate is enabled (it will auto-generate)
                pdfExportBtn.style.display = 'none';
            }
        }

        function hidePdfButton() {
            const pdfSection = document.getElementById('pdfExportSection');
            if (pdfSection) {
                pdfSection.style.display = 'none';
            }

            // Reset download link and export button visibility
            const downloadLink = document.getElementById('pdfDownloadLink');
            if (downloadLink) {
                downloadLink.style.display = 'none';
            }

            const exportBtn = document.getElementById('pdfExportBtn');
            if (exportBtn) {
                // Only show export button if auto-generate is disabled
                const autoGenerateCheckbox = document.getElementById('autoGeneratePdf');
                if (autoGenerateCheckbox && !autoGenerateCheckbox.checked) {
                    exportBtn.style.display = 'inline-block';
                } else {
                    exportBtn.style.display = 'none';
                }
            }
        }

        // Handle PDF auto-generate toggle change
        document.addEventListener('DOMContentLoaded', function() {
            const autoGenerateCheckbox = document.getElementById('autoGeneratePdf');
            if (autoGenerateCheckbox) {
                autoGenerateCheckbox.addEventListener('change', function() {
                    // Update PDF button visibility based on toggle state
                    const pdfExportBtn = document.getElementById('pdfExportBtn');
                    const pdfSection = document.getElementById('pdfExportSection');
                    
                    if (this.checked) {
                        // Auto-generate enabled: hide manual button
                        if (pdfExportBtn) {
                            pdfExportBtn.style.display = 'none';
                        }
                    } else {
                        // Auto-generate disabled: show manual button if PDF is ready
                        if (pdfSection && pdfSection.style.display !== 'none' && pdfExportBtn) {
                            pdfExportBtn.style.display = 'inline-block';
                        }
                    }
                });
            }
        });

        // Debate Library Functions
        function updateDebateCount(count) {
            const countLabel = document.getElementById('debateLibraryCount');
            if (countLabel) {
                countLabel.textContent = `Debate Library (${count} debate${count !== 1 ? 's' : ''} available)`;
            }
        }

        async function loadDebateCount() {
            try {
                const response = await fetch('/debate_library');
                if (response.ok) {
                    const data = await response.json();
                    const count = (data.debates || []).length;
                    updateDebateCount(count);
                }
            } catch (error) {
                console.error('Error loading debate count:', error);
                updateDebateCount(0);
            }
        }

        async function loadDebateLibrary() {
            try {
                const response = await fetch('/debate_library');
                if (!response.ok) {
                    throw new Error('Failed to load debate library');
                }
                const data = await response.json();
                debateLibrary = data.debates || [];

                // Update debate count in the header
                updateDebateCount(debateLibrary.length);

                displayDebateLibrary();
            } catch (error) {
                console.error('Error loading debate library:', error);
                const debateList = document.getElementById('debateList');
                if (debateList) {
                    debateList.innerHTML = '<div style="text-align: center; padding: 20px; color: #c55a11;">Failed to load debate library</div>';
                }
            }
        }

        function displayDebateLibrary() {
            const debateList = document.getElementById('debateList');
            if (!debateList || debateLibrary.length === 0) return;

            debateList.innerHTML = '';

            debateLibrary.forEach((debate, index) => {
                const debateItem = document.createElement('div');
                debateItem.style.cssText = 'padding: 10px; margin-bottom: 8px; border: 1px solid #d0d0d0; border-radius: 4px; background: #f9f9f9; cursor: pointer; transition: background 0.2s;';
                debateItem.onmouseover = () => debateItem.style.background = '#e7f3ff';
                debateItem.onmouseout = () => debateItem.style.background = '#f9f9f9';

                debateItem.innerHTML = `
                    <div style="display: flex; align-items: start; gap: 10px;">
                        <input type="checkbox" id="debate-${debate.id}" class="debate-checkbox" onchange="updateDebateSelectionCount()" style="margin-top: 3px; width: 18px; height: 18px; cursor: pointer;">
                        <label for="debate-${debate.id}" style="flex: 1; cursor: pointer; margin: 0;">
                            <div style="font-weight: 600; color: #1f4e78; margin-bottom: 4px;">${debate.name}</div>
                            <div style="font-size: 12px; color: #808080;">${debate.description}</div>
                        </label>
                    </div>
                `;

                debateList.appendChild(debateItem);
            });

            updateDebateSelectionCount();
        }

        function toggleDebateLibrary() {
            const section = document.getElementById('debateLibrarySection');
            const toggle = document.getElementById('debateLibraryToggle');

            if (section.style.display === 'none') {
                section.style.display = 'block';
                toggle.textContent = '‚ñº';
                // Load debate library if not already loaded
                if (debateLibrary.length === 0) {
                    loadDebateLibrary();
                }
            } else {
                section.style.display = 'none';
                toggle.textContent = '‚ñ∂';
            }
        }

        function selectAllDebates() {
            const checkboxes = document.querySelectorAll('.debate-checkbox');
            checkboxes.forEach(cb => cb.checked = true);
            updateDebateSelectionCount();
        }

        function deselectAllDebates() {
            const checkboxes = document.querySelectorAll('.debate-checkbox');
            checkboxes.forEach(cb => cb.checked = false);
            updateDebateSelectionCount();
        }

        function updateDebateSelectionCount() {
            const checkboxes = document.querySelectorAll('.debate-checkbox:checked');
            const count = checkboxes.length;
            const countEl = document.getElementById('debateSelectionCount');
            if (countEl) {
                countEl.textContent = `${count} debate${count !== 1 ? 's' : ''} selected`;
                countEl.style.color = count > 0 ? '#4472c4' : '#808080';
            }

            // Disable Start Dialog button if debates are selected
            const startBtn = document.getElementById('startBtn');
            if (startBtn) {
                if (count > 0) {
                    startBtn.disabled = true;
                    startBtn.title = "Cannot start manual dialog while library debates are selected";
                    startBtn.style.opacity = "0.5";
                    startBtn.style.cursor = "not-allowed";
                } else {
                    startBtn.disabled = false;
                    startBtn.title = "";
                    startBtn.style.opacity = "1";
                    startBtn.style.cursor = "pointer";
                }
            }
        }

        function loadSelectedDebates() {
            const checkboxes = document.querySelectorAll('.debate-checkbox:checked');
            if (checkboxes.length === 0) {
                showStatus('Please select at least one debate', 'error');
                return;
            }

            // Get selected debates
            debateQueue = [];
            checkboxes.forEach(cb => {
                const debateId = cb.id.replace('debate-', '');
                const debate = debateLibrary.find(d => d.id === debateId);
                if (debate) {
                    debateQueue.push(debate);
                }
            });

            // Start queue
            startDebateQueue();
        }

        function startDebateQueue() {
            if (debateQueue.length === 0) return;

            isQueueRunning = true;
            queueCancelled = false;
            waitingForNextDebate = false;
            currentDebateIndex = 0;

            // Show progress indicator
            const progressEl = document.getElementById('debateQueueProgress');
            if (progressEl) {
                progressEl.style.display = 'block';
            }

            // Update progress display
            updateQueueProgress();

            // Start first debate
            runNextDebateInQueue();
        }

        function updateQueueProgress() {
            const completed = currentDebateIndex;
            const remaining = debateQueue.length - currentDebateIndex - (dialogActive ? 1 : 0);
            const total = debateQueue.length;
            const current = dialogActive && currentDebateIndex < debateQueue.length
                ? (currentDebateIndex + 1)
                : '-';

            document.getElementById('queueCompleted').textContent = completed;
            document.getElementById('queueCurrent').textContent = current;
            document.getElementById('queueRemaining').textContent = remaining;
            document.getElementById('queueTotal').textContent = total;

            const progress = (completed / total) * 100;
            document.getElementById('queueProgressBar').style.width = `${progress}%`;

            if (currentDebateIndex < debateQueue.length) {
                const currentDebate = debateQueue[currentDebateIndex];
                document.getElementById('queueCurrentDebate').textContent =
                    `Current: ${currentDebate.name}`;
            }
        }

        function updateTurnProgress() {
            if (!isQueueRunning || !dialogActive) {
                document.getElementById('queueTurnProgress').style.display = 'none';
                return;
            }

            document.getElementById('queueTurnProgress').style.display = 'block';
            document.getElementById('turnTotal').textContent = currentDebateTotalTurns;
            document.getElementById('turnDone').textContent = currentDebateTurnsDone;
            document.getElementById('turnLeft').textContent = Math.max(0, currentDebateTotalTurns - currentDebateTurnsDone);
        }

        function runNextDebateInQueue() {
            // Reset the flag
            waitingForNextDebate = false;

            if (queueCancelled) {
                endDebateQueue('Queue cancelled by user');
                return;
            }

            if (currentDebateIndex >= debateQueue.length) {
                endDebateQueue('All debates completed!');
                return;
            }

            const debate = debateQueue[currentDebateIndex];

            // Load debate into form fields
            document.getElementById('intermediator-pre-prompt').value = debate.intermediator_pre_prompt || '';
            document.getElementById('intermediator-topic-prompt').value = debate.intermediator_topic_prompt || '';
            document.getElementById('participant-pre-prompt').value = debate.participant_pre_prompt || '';
            document.getElementById('participant1-mid-prompt').value = debate.participant1_mid_prompt || '';
            document.getElementById('participant2-mid-prompt').value = debate.participant2_mid_prompt || '';
            document.getElementById('participant-post-prompt').value = debate.participant_post_prompt || '';
            document.getElementById('maxTurns').value = debate.max_turns || 3;

            // Set up turn tracking for this debate
            // Total turns = intro (1) + participant turns (max_turns * 2) + moderations (max_turns * 2) + summary (1)
            // Actually, let's count participant turns only: max_turns * 2
            currentDebateTotalTurns = (debate.max_turns || 3) * 2;
            currentDebateTurnsDone = 0;

            // Update progress
            updateQueueProgress();
            updateTurnProgress();

            // Start the dialog
            setTimeout(() => {
                startDialog();
            }, 500);
        }

        function cancelDebateQueue() {
            if (confirm('Are you sure you want to cancel the debate queue?')) {
                queueCancelled = true;
                isQueueRunning = false;

                // Update status bar
                updateStatusBar('idle', 'Debate queue cancelled by user', null);

                // Hide progress indicator
                const progressEl = document.getElementById('debateQueueProgress');
                if (progressEl) {
                    progressEl.style.display = 'none';
                }

                showStatus('Debate queue cancelled', 'info');
            }
        }

        function endDebateQueue(message) {
            isQueueRunning = false;
            queueCancelled = false;
            waitingForNextDebate = false;

            // Update status bar to show queue completion
            updateStatusBar('idle', message, null);

            // Hide progress indicator after a delay
            setTimeout(() => {
                const progressEl = document.getElementById('debateQueueProgress');
                if (progressEl) {
                    progressEl.style.display = 'none';
                }
            }, 3000);

            showStatus(message, 'success');
        }

        async function exportToPdf() {
            if (!currentDialogId) {
                showStatus('No dialog available for export', 'error');
                return;
            }

            const pdfBtn = document.getElementById('pdfExportBtn');
            const originalText = pdfBtn ? pdfBtn.textContent : '';
            if (pdfBtn) {
                pdfBtn.disabled = true;
                pdfBtn.textContent = 'Generating PDF...';
            }

            try {
                const response = await fetch(`/generate_pdf/${currentDialogId}`);

                if (!response.ok) {
                    // Try to parse error as JSON, but fallback to text if it fails
                    let errorMessage = 'Failed to generate PDF';
                    try {
                        const errorData = await response.json();
                        errorMessage = errorData.error || errorMessage;
                    } catch (e) {
                        const errorText = await response.text();
                        errorMessage = errorText || errorMessage;
                    }
                    throw new Error(errorMessage);
                }

                // Get the PDF blob
                const blob = await response.blob();

                // Create download link
                const url = window.URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `dialog_${currentDialogId}.pdf`;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);

                // Open PDF in new tab
                const pdfWindow = window.open(url, '_blank');
                if (pdfWindow) {
                    pdfWindow.focus();
                }

                // Revoke URL after a delay to allow download/opening
                setTimeout(() => {
                    window.URL.revokeObjectURL(url);
                }, 1000);

                showStatus('PDF generated and opened', 'success');
            } catch (error) {
                console.error('Error exporting PDF:', error);
                showStatus(`Error: ${error.message}`, 'error');
            } finally {
                if (pdfBtn) {
                    pdfBtn.disabled = false;
                    pdfBtn.textContent = originalText;
                }
            }
        }

        // Audio playback functionality
        let audioPlayer = null;
        let audioPlaylist = [];
        let currentAudioIndex = 0;
        let isAudioPlaying = false;


        function playNextAudio(retryCount = 0) {
            if (!isAudioPlaying || currentAudioIndex >= audioPlaylist.length) {
                // Playback complete
                stopAudioDebate();
                const audioStatus = document.getElementById('audioStatus');
                audioStatus.textContent = 'Audio playback complete';
                audioStatus.style.color = '#70ad47';
                setTimeout(() => {
                    audioStatus.textContent = '';
                }, 3000);
                return;
            }

            const filename = audioPlaylist[currentAudioIndex];
            const audioUrl = `/audio/${currentDialogId}/${filename}`;
            const audioStatus = document.getElementById('audioStatus');

            // Extract speaker name from filename (e.g., "001_intermediator.mp3")
            const speakerMatch = filename.match(/^(\d+)_([^.]+)\.mp3/);
            let displayName = filename;
            if (speakerMatch) {
                const turn = parseInt(speakerMatch[1]);
                const speaker = speakerMatch[2];
                const speakerNames = {
                    'intermediator': 'Moderator',
                    'participant1': 'Participant 1',
                    'participant2': 'Participant 2'
                };
                displayName = `${speakerNames[speaker] || speaker} (Turn ${turn})`;
            }

            const statusText = retryCount > 0
                ? `Retrying: ${displayName} (${currentAudioIndex + 1}/${audioPlaylist.length}) - Attempt ${retryCount + 1}`
                : `Playing: ${displayName} (${currentAudioIndex + 1}/${audioPlaylist.length})`;

            audioStatus.textContent = statusText;
            audioStatus.style.color = retryCount > 0 ? '#ffc000' : '#4472c4';

            // Create or reuse audio element
            if (audioPlayer) {
                audioPlayer.pause();
                audioPlayer.src = '';
            }

            audioPlayer = new Audio(audioUrl);

            // Handle audio events
            audioPlayer.addEventListener('ended', () => {
                currentAudioIndex++;
                playNextAudio(0);
            });

            audioPlayer.addEventListener('error', (e) => {
                console.error('Audio playback error:', {
                    filename: filename,
                    url: audioUrl,
                    error: e,
                    mediaError: audioPlayer.error,
                    retryCount: retryCount
                });

                // Get detailed error message
                let errorDetail = 'Unknown error';
                if (audioPlayer.error) {
                    switch (audioPlayer.error.code) {
                        case 1: errorDetail = 'Audio loading aborted'; break;
                        case 2: errorDetail = 'Network error'; break;
                        case 3: errorDetail = 'Audio decoding failed'; break;
                        case 4: errorDetail = 'Audio format not supported'; break;
                    }
                }

                // Retry up to 3 times with exponential backoff
                if (retryCount < 3) {
                    const retryDelay = Math.pow(2, retryCount) * 500; // 500ms, 1s, 2s
                    audioStatus.textContent = `Error: ${errorDetail}. Retrying ${displayName} in ${retryDelay / 1000}s...`;
                    audioStatus.style.color = '#ffc000';
                    setTimeout(() => {
                        playNextAudio(retryCount + 1);
                    }, retryDelay);
                } else {
                    // After 3 retries, skip to next
                    audioStatus.textContent = `Failed to play ${displayName} after 3 attempts. Skipping... (${errorDetail})`;
                    audioStatus.style.color = '#c55a11';
                    console.warn(`Skipping audio file after 3 failed attempts: ${filename}`);
                    setTimeout(() => {
                        currentAudioIndex++;
                        playNextAudio(0);
                    }, 2000);
                }
            });

            // Start playback
            audioPlayer.play().catch(error => {
                console.error('Error starting audio playback:', error);
                audioStatus.textContent = 'Error: Unable to play audio. User interaction may be required.';
                audioStatus.style.color = '#c55a11';
                stopAudioDebate();
            });
        }

        // Save to Library functionality
        function showSaveToLibraryDialog() {
            // Check if prompts are filled
            const topicPrompt = document.getElementById('intermediator-topic-prompt').value.trim();
            if (!topicPrompt) {
                alert('Please fill in the Intermediator Topic/Instructions Prompt before saving to library');
                return;
            }

            const dialog = document.getElementById('saveToLibraryModal');
            dialog.style.display = 'flex';
        }

        function closeSaveToLibraryDialog() {
            const dialog = document.getElementById('saveToLibraryModal');
            dialog.style.display = 'none';
            // Clear form
            document.getElementById('debateName').value = '';
            document.getElementById('debateDescription').value = '';
        }

        async function saveToLibrary() {
            // Get debate details
            const name = document.getElementById('debateName').value.trim();
            const description = document.getElementById('debateDescription').value.trim();
            const maxTurns = parseInt(document.getElementById('maxTurns').value) || 4;
            const topicPrompt = document.getElementById('intermediator-topic-prompt').value.trim();

            if (!name || !description) {
                alert('Please fill in Name and Description fields');
                return;
            }

            // Auto-generate ID from name
            // Convert to lowercase, replace spaces and special chars with underscores
            let id = name.toLowerCase()
                .replace(/[^a-z0-9]+/g, '_')  // Replace non-alphanumeric with underscore
                .replace(/^_+|_+$/g, '')      // Remove leading/trailing underscores
                .substring(0, 50);             // Limit length

            // Add timestamp suffix to ensure uniqueness
            const timestamp = Date.now().toString().slice(-6);
            id = `${id}_${timestamp}`;

            // Collect all prompt data
            const debateData = {
                id: id,
                name: name,
                description: description,
                intermediator_pre_prompt: document.getElementById('intermediator-pre-prompt').value.trim(),
                intermediator_topic_prompt: topicPrompt,
                participant_pre_prompt: document.getElementById('participant-pre-prompt').value.trim(),
                participant1_mid_prompt: document.getElementById('participant1-mid-prompt').value.trim(),
                participant2_mid_prompt: document.getElementById('participant2-mid-prompt').value.trim(),
                participant_post_prompt: document.getElementById('participant-post-prompt').value.trim(),
                max_turns: maxTurns
            };

            console.log('Saving debate data:', debateData);

            try {
                const response = await fetch('/save_debate', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify(debateData)
                });

                const result = await response.json();
                console.log('Server response:', result);

                if (response.ok) {
                    alert(`Debate "${name}" saved to library successfully!`);
                    closeSaveToLibraryDialog();
                    // Reload debate library
                    await loadDebateLibrary();
                } else {
                    alert(`Error saving debate: ${result.error}`);
                }
            } catch (error) {
                console.error('Error saving debate:', error);
                alert('Failed to save debate to library: ' + error.message);
            }
        }

        // Reset prompt fields to current defaults
        function resetPromptsToDefaults() {
            if (!confirm('Reset pre/post prompts to current defaults? This will clear any customizations.')) {
                return;
            }

            // Clear localStorage for these fields
            localStorage.removeItem('idi_intermediator_pre_prompt');
            localStorage.removeItem('idi_participant_pre_prompt');
            localStorage.removeItem('idi_participant_post_prompt');

            // Update form fields with current defaults
            document.getElementById('intermediator-pre-prompt').value = DEFAULT_PROMPTS.intermediator_pre_prompt;
            document.getElementById('participant-pre-prompt').value = DEFAULT_PROMPTS.participant_pre_prompt;
            document.getElementById('participant-post-prompt').value = DEFAULT_PROMPTS.participant_post_prompt;

            alert('Prompts reset to defaults!');
        }

        // Default Prompts Editor functionality
        async function showDefaultPromptsEditor() {
            try {
                const response = await fetch('/default_prompts');
                const data = await response.json();

                if (response.ok && data.prompts) {
                    // Populate the editor with current default prompts
                    document.getElementById('editIntermediatorPrePrompt').value = data.prompts.intermediator_pre_prompt || '';
                    document.getElementById('editParticipantPrePrompt').value = data.prompts.participant_pre_prompt || '';
                    document.getElementById('editParticipantPostPrompt').value = data.prompts.participant_post_prompt || '';

                    // Display last updated timestamp
                    const timestamp = data.last_updated ? new Date(data.last_updated).toLocaleString() : 'Unknown';
                    document.getElementById('lastUpdatedTimestamp').textContent = `Last updated: ${timestamp}`;

                    // Show the modal
                    const modal = document.getElementById('defaultPromptsModal');
                    modal.style.display = 'flex';
                } else {
                    alert('Failed to load default prompts: ' + (data.error || 'Unknown error'));
                }
            } catch (error) {
                console.error('Error loading default prompts:', error);
                alert('Failed to load default prompts: ' + error.message);
            }
        }

        function closeDefaultPromptsEditor() {
            const modal = document.getElementById('defaultPromptsModal');
            modal.style.display = 'none';
        }

        async function saveDefaultPrompts() {
            const prompts = {
                intermediator_pre_prompt: document.getElementById('editIntermediatorPrePrompt').value.trim(),
                participant_pre_prompt: document.getElementById('editParticipantPrePrompt').value.trim(),
                participant_post_prompt: document.getElementById('editParticipantPostPrompt').value.trim()
            };

            // Validate that all fields are filled
            if (!prompts.intermediator_pre_prompt || !prompts.participant_pre_prompt || !prompts.participant_post_prompt) {
                alert('All prompt fields are required. Please fill in all prompts.');
                return;
            }

            try {
                const response = await fetch('/update_default_prompts', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({ prompts })
                });

                const result = await response.json();

                if (response.ok) {
                    // Update the in-memory defaults
                    DEFAULT_PROMPTS = prompts;

                    // Clear localStorage for default prompt fields so new defaults take effect
                    localStorage.removeItem('idi_intermediator_pre_prompt');
                    localStorage.removeItem('idi_participant_pre_prompt');
                    localStorage.removeItem('idi_participant_post_prompt');

                    // Update the form fields with the new defaults
                    document.getElementById('intermediator-pre-prompt').value = prompts.intermediator_pre_prompt;
                    document.getElementById('participant-pre-prompt').value = prompts.participant_pre_prompt;
                    document.getElementById('participant-post-prompt').value = prompts.participant_post_prompt;

                    closeDefaultPromptsEditor();
                    alert('Default prompts updated successfully!\n\nPrevious version has been archived.\nThe new defaults are now active in the form.');
                } else {
                    alert('Failed to update default prompts: ' + (result.error || 'Unknown error'));
                }
            } catch (error) {
                console.error('Error saving default prompts:', error);
                alert('Failed to save default prompts: ' + error.message);
            }
        }

    </script>

    <!-- Save to Library Modal -->
    <div id="saveToLibraryModal"
        style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.5); z-index: 10000; justify-content: center; align-items: center;">
        <div
            style="background: #ffffff; padding: 24px; border-radius: 8px; max-width: 500px; width: 90%; box-shadow: 0 4px 12px rgba(0,0,0,0.3);">
            <h3 style="margin-top: 0; color: #1f4e78;">Save Debate to Library</h3>

            <div style="margin-bottom: 16px;">
                <label style="display: block; margin-bottom: 4px; font-weight: 600; color: #1f4e78;">Debate Name <span
                        style="color: #c55a11;">*</span></label>
                <input type="text" id="debateName" placeholder="e.g., My Custom Debate"
                    style="width: 100%; padding: 8px; border: 1px solid #d0d0d0; border-radius: 4px; box-sizing: border-box;">
                <div style="font-size: 11px; color: #808080; margin-top: 4px;">Display name for the debate</div>
            </div>

            <div style="margin-bottom: 16px;">
                <label style="display: block; margin-bottom: 4px; font-weight: 600; color: #1f4e78;">Description <span
                        style="color: #c55a11;">*</span></label>
                <textarea id="debateDescription" placeholder="Brief description of the debate topic"
                    style="width: 100%; padding: 8px; border: 1px solid #d0d0d0; border-radius: 4px; box-sizing: border-box; min-height: 60px; resize: vertical;"></textarea>
                <div style="font-size: 11px; color: #808080; margin-top: 4px;">Short summary of what this debate is
                    about</div>
            </div>

            <div style="display: flex; gap: 10px; justify-content: flex-end;">
                <button onclick="closeSaveToLibraryDialog()"
                    style="padding: 8px 16px; background: #808080; color: #ffffff; border: none; border-radius: 4px; cursor: pointer;">Cancel</button>
                <button onclick="saveToLibrary()"
                    style="padding: 8px 16px; background: #9d60d6; color: #ffffff; border: none; border-radius: 4px; cursor: pointer;">üíæ
                    Save</button>
            </div>
        </div>
    </div>

    <!-- Default Prompts Editor Modal -->
    <div id="defaultPromptsModal"
        style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.5); z-index: 10000; justify-content: center; align-items: center; overflow-y: auto;">
        <div
            style="background: #ffffff; padding: 24px; border-radius: 8px; max-width: 700px; width: 90%; box-shadow: 0 4px 12px rgba(0,0,0,0.3); margin: 20px auto; max-height: 90vh; overflow-y: auto;">
            <h3 style="margin-top: 0; color: #1f4e78;">Edit Default Prompts</h3>
            <div style="font-size: 12px; color: #666; margin-bottom: 20px;">
                These default prompts are used when creating new custom dialogs. Changes will be saved and archived.
            </div>

            <div style="margin-bottom: 20px;">
                <label style="display: block; margin-bottom: 4px; font-weight: 600; color: #1f4e78;">Intermediator Pre-Prompt</label>
                <textarea id="editIntermediatorPrePrompt"
                    style="width: 100%; padding: 8px; border: 1px solid #d0d0d0; border-radius: 4px; box-sizing: border-box; min-height: 120px; resize: vertical; font-family: monospace; font-size: 12px;"></textarea>
                <div style="font-size: 11px; color: #808080; margin-top: 4px;">Default instructions for the intermediator role</div>
            </div>

            <div style="margin-bottom: 20px;">
                <label style="display: block; margin-bottom: 4px; font-weight: 600; color: #1f4e78;">Participant Pre-Prompt</label>
                <textarea id="editParticipantPrePrompt"
                    style="width: 100%; padding: 8px; border: 1px solid #d0d0d0; border-radius: 4px; box-sizing: border-box; min-height: 80px; resize: vertical; font-family: monospace; font-size: 12px;"></textarea>
                <div style="font-size: 11px; color: #808080; margin-top: 4px;">Default instructions for participant role</div>
            </div>

            <div style="margin-bottom: 20px;">
                <label style="display: block; margin-bottom: 4px; font-weight: 600; color: #1f4e78;">Participant Post-Prompt</label>
                <textarea id="editParticipantPostPrompt"
                    style="width: 100%; padding: 8px; border: 1px solid #d0d0d0; border-radius: 4px; box-sizing: border-box; min-height: 60px; resize: vertical; font-family: monospace; font-size: 12px;"></textarea>
                <div style="font-size: 11px; color: #808080; margin-top: 4px;">Default instructions for response formatting</div>
            </div>

            <div style="display: flex; gap: 10px; justify-content: space-between; align-items: center;">
                <div style="font-size: 11px; color: #666;">
                    <span id="lastUpdatedTimestamp"></span>
                </div>
                <div style="display: flex; gap: 10px;">
                    <button onclick="closeDefaultPromptsEditor()"
                        style="padding: 8px 16px; background: #808080; color: #ffffff; border: none; border-radius: 4px; cursor: pointer;">Cancel</button>
                    <button onclick="saveDefaultPrompts()"
                        style="padding: 8px 16px; background: #4472c4; color: #ffffff; border: none; border-radius: 4px; cursor: pointer;">üíæ Save</button>
                </div>
            </div>
        </div>
    </div>

</body>

</html>